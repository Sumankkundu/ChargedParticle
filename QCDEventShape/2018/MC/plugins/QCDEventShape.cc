// -*- C++ -*-
//
// Package:    Test/QCDEventShape
// Class:      QCDEventShape
// 
/**\class QCDEventShape QCDEventShape.cc Test/QCDEventShape/plugins/QCDEventShape.cc

 Description: [one line class summary]

 Implementation:
     [Notes on implementation]
*/
//
// Original Author:  Tanmay Sarkar
//         Created:  Wed, 01 Jul 2015 10:24:21 GMT
//
//


// system include files

#define DIJETAVE 

////for data
//#define JETENERGY
//#define TRIGGER

// //for Madgraph
//#define LHAPDF
//#define JETRESO
//#define TRACKSYS
//#define TRIGGER

////for Pythia8
#define JETRESO
#define TRIGGER

//For Flat
#define FLAT


////For GenParticle only
//#define GENPART


#include <memory>
#include <map>
#include <string>
#include <vector>
#include "TCanvas.h"
#include "TFormula.h"
#include "TFile.h"
#include "TH1F.h"
#include "TTree.h"
#include <cmath>
#include "TMath.h"
#include "CLHEP/Vector/LorentzVector.h"
#include "TRandom.h"

#include "TH2F.h"
#include "TProfile.h"
#include <fstream>
#include <iostream>

// user include files
#include "FWCore/Framework/interface/Frameworkfwd.h"
#include "FWCore/Framework/interface/EDAnalyzer.h"

#include "FWCore/Framework/interface/Event.h"
#include "FWCore/Framework/interface/MakerMacros.h"

#include "FWCore/ParameterSet/interface/ParameterSet.h"
#include <time.h>
#include "FWCore/Framework/interface/Event.h"
#include "FWCore/Utilities/interface/InputTag.h"
#include "FWCore/ServiceRegistry/interface/Service.h"
#include "CommonTools/UtilAlgos/interface/TFileService.h"
#include "DataFormats/PatCandidates/interface/Electron.h"
#include "DataFormats/PatCandidates/interface/Photon.h"
#include "DataFormats/PatCandidates/interface/Muon.h"
#include "DataFormats/PatCandidates/interface/Tau.h"
#include "DataFormats/PatCandidates/interface/Jet.h"
#include "DataFormats/PatCandidates/interface/MET.h"
#include "DataFormats/HepMCCandidate/interface/GenParticle.h"
#include "FWCore/ServiceRegistry/interface/Service.h"
#include "DataFormats/JetReco/interface/GenJet.h"
#include "DataFormats/Candidate/interface/Candidate.h"
#include "DataFormats/PatCandidates/interface/PackedGenParticle.h"
#include "DataFormats/VertexReco/interface/VertexFwd.h"
#include "DataFormats/VertexReco/interface/Vertex.h"
#include "DataFormats/JetReco/interface/PFJetCollection.h"
#include "DataFormats/Math/interface/deltaR.h"
#include "FWCore/Common/interface/TriggerNames.h"
#include "DataFormats/Common/interface/TriggerResults.h"
#include "L1Trigger/GlobalTriggerAnalyzer/interface/L1GtTrigReport.h"
#include "CondFormats/L1TObjects/interface/L1GtTriggerMenu.h"
#include "CondFormats/DataRecord/interface/L1GtTriggerMenuRcd.h"
#include "L1Trigger/GlobalTriggerAnalyzer/interface/L1GtTrigReportEntry.h"
#include "CondFormats/DataRecord/interface/L1GtStableParametersRcd.h"
#include "DataFormats/PatCandidates/interface/TriggerObjectStandAlone.h"
#include "DataFormats/PatCandidates/interface/PackedTriggerPrescales.h"
#include "HLTrigger/HLTcore/interface/HLTConfigProvider.h"

#include "DataFormats/JetReco/interface/PFJetCollection.h"
#include "SimDataFormats/GeneratorProducts/interface/PdfInfo.h"
#include "SimDataFormats/GeneratorProducts/interface/HepMCProduct.h"
#include "SimDataFormats/GeneratorProducts/interface/GenEventInfoProduct.h"
#include "SimDataFormats/GeneratorProducts/interface/GenRunInfoProduct.h"
#include "SimDataFormats/GeneratorProducts/interface/LHERunInfoProduct.h"
#include "SimDataFormats/GeneratorProducts/interface/LHEEventProduct.h"

#include "DataFormats/L1GlobalTrigger/interface/L1GlobalTriggerReadoutRecord.h"
#include "DataFormats/Common/interface/TriggerResults.h"
#include "DataFormats/HLTReco/interface/TriggerEvent.h"
#include "HLTrigger/HLTcore/interface/HLTConfigProvider.h"
//#include "FWCore/Framework/interface/TriggerNames.h"
#include "FWCore/Common/interface/TriggerNames.h"
#include "DataFormats/Luminosity/interface/LumiDetails.h"

#include "Test/QCDEventShape/plugins/EventShape_vector.h" 


#include "DataFormats/Common/interface/View.h"
#include "DataFormats/TrackReco/interface/Track.h"
#include "DataFormats/TrackReco/interface/TrackFwd.h"
#include "DataFormats/TrackReco/interface/TrackBase.h"
#include "DataFormats/BeamSpot/interface/BeamSpot.h"
#include "CommonTools/Statistics/interface/ChiSquaredProbability.h"

#include "SimDataFormats/PileupSummaryInfo/interface/PileupSummaryInfo.h"

//#include "HLTrigger/HLTcore/interface/HLTPrescaleProvider.h"
//#include "JetMETCorrections/Modules/interface/JetResolution.h"
//#include "CondFormats/JetMETObjects/interface/JetResolutionObject.h"
#include "PhysicsTools/PatUtils/interface/SmearedJetProducerT.h"
#include "PhysicsTools/PatAlgos/plugins/JetCorrFactorsProducer.h"
//#include <JetMETCorrections/Modules/interface/JetResolution.h>
#include <FWCore/Framework/interface/EventSetup.h>
#include <FWCore/Framework/interface/ESHandle.h>
#include <CondFormats/DataRecord/interface/JetResolutionRcd.h>
#include <CondFormats/DataRecord/interface/JetResolutionScaleFactorRcd.h>
#include "FWCore/Utilities/interface/typelookup.h"
#include "CondFormats/JetMETObjects/interface/JetCorrectorParameters.h"
#include "CondFormats/JetMETObjects/interface/JetCorrectionUncertainty.h"
#include "HLTrigger/HLTcore/interface/HLTPrescaleProvider.h"
#include "HLTrigger/HLTcore/interface/HLTConfigProvider.h"
#include "PhysicsTools/Utilities/interface/LumiReWeighting.h"

using namespace edm;
using namespace reco;
using namespace std;
using namespace CLHEP;
using namespace trigger;
using namespace math;
static const int nvar=32;
static const int nhist=10;
static const int typen=2;

static const int nHLTmx=8; 
const char* varname[nvar]={"y3anti", "y3ceanti", "y3cranti", "thrustc", "thrustce", "thrustcr",
                           "minorc", "minorce", "minorcr", "tmass", "tmasse", "tmassr",
                           "hmass", "hmasse", "hmassr", "y3c", "y3ce", "y3cr",
                           "broadt", "broadte", "broadtr", "broadw", "broadwe", "broadwr",
                           "ttmass", "ttmasse", "ttmassr", "htmass", "htmasse", "htmassr",
                           "sphericity", "cparameter"};

const char* vartitle[nvar]={"Anti-Y_{23,C} ", "Anti-Y_{23,E} ", "Anti-Y_{23,R} ",
                            "#tau_{_{#perp} _{   ,C}} ", "#tau_{_{#perp} _{   ,E}} ", "#tau_{_{#perp} _{   ,R}} ",
                            "T_{ m,C} ", "T_{ m,E} ", "T_{ m,R} ",
                            "#rho_{Tot,C} ", "#rho_{Tot,E} ", "#rho_{Tot,R} ",
                            "#rho_{H,C} ", "#rho_{H,E} ", "#rho_{H,R} ",
                            "Y_{23,C} ", "Y_{23,E} ", "Y_{23,R} ",
                            "B_{ T,C} ", "B_{ T,E} ", "B_{ T,R} ",
                            "B_{ W,C} ", "B_{ W,E} ", "B_{ W,R} ",
                            "#rho^{T}_{Tot,C} ", "#rho^{T}_{Tot,E} ", "#rho^{T}_{Tot,R} ",
                            "#rho^{T}_{H,C} ", "#rho^{T}_{H,E} ", "#rho^{T}_{H,R} ",
                            "S_{_{#perp} _{   ,C}}", "C-parameter_{C}"};

//Used for gen level MC (coarse)
int nbinsxgen[nvar]={24, 24, 30, 24, 24, 24,
                    24, 24, 24, 30, 30, 30,
                    30, 30, 30, 60, 60, 60,
                    30, 30, 30, 30, 30, 30,
                    30, 30, 30, 30, 30, 30,
                    30, 30};


//////////////Modify/////////////
//For Jets

const int nmxbins=18;
int nbinsx0[nvar][nHLTmx]={{},{},{},
                   {13,13,13,15,15,17,16,18},//3
                   {},{},{},{},{},
                   {10,10,11,12,12,13,13,12},//9
                   {},{},{},{},{},
                   {4,4,5,5,6,6,6,7},//15
                   {},{},
                   {8,7,7,8,9,11,11,12},//18
                   {},{},{},{},{},
                   {8,8,10,11,11,12,13,13},//24
                   {},{},{},{},{},{},{}};

//For charge Particles
int nbinsx1[nvar][nHLTmx]={{},{},{},
                   {11,12,12,12,13,12,11,9},//3
                   {},{},{},{},{},
                   {8,8,8,8,9,9,8,7},//9
                   {},{},{},{},{},
                   {4,4,4,4,4,4,4,4},//15
                   {},{},
                   {9,9,9,9,9,9,8,7},//18
                   {},{},{},{},{},
                   {6,7,8,8,8,8,8,7},//24
                   {},{},{},{},{},{},{}};
///////////////////Modify /////////////////////////////
//for Jets
double binrngs0[nvar][nHLTmx][nmxbins+1] ={
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        //Thrust 3
        {{-6.71, -5.87, -5.18, -4.59, -4.07, -3.6, -3.17, -2.77, -2.4, -2.05, -1.73, -1.43, -1.16, -0.91},
{-6.71, -5.76, -5.09, -4.53, -4.04, -3.58, -3.15, -2.74, -2.35, -1.98, -1.65, -1.36, -1.12, -0.92},
{-6.71, -5.78, -5.14, -4.61, -4.14, -3.7, -3.28, -2.87, -2.48, -2.11, -1.77, -1.47, -1.22, -1.02},
{-6.71, -5.94, -5.33, -4.8, -4.32, -3.87, -3.44, -3.03, -2.64, -2.28, -1.94, -1.64, -1.38, -1.16, -0.97, -0.82},
{-6.71, -5.99, -5.4, -4.88, -4.4, -3.95, -3.52, -3.11, -2.72, -2.36, -2.03, -1.74, -1.48, -1.27, -1.1, -0.96},
{-6.71, -6.04, -5.46, -4.94, -4.46, -4, -3.57, -3.16, -2.77, -2.41, -2.09, -1.8, -1.55, -1.35, -1.18, -1.05, -0.95, -0.87},
{-6.71, -6.04, -5.45, -4.92, -4.43, -3.97, -3.54, -3.14, -2.77, -2.43, -2.12, -1.84, -1.6, -1.39, -1.21, -1.06, -0.94},
{-6.71, -6.06, -5.48, -4.95, -4.46, -4, -3.57, -3.18, -2.82, -2.49, -2.2, -1.94, -1.71, -1.51, -1.34, -1.2, -1.09, -1, -0.92}},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        //RhoT 9
        {{-4.99, -4.44, -3.89, -3.35, -2.82, -2.3, -1.81, -1.35, -0.93, -0.56, -0.24},
{-4.99, -4.43, -3.88, -3.35, -2.83, -2.33, -1.85, -1.4, -0.99, -0.62, -0.29 },
{-4.99, -4.44, -3.93, -3.44, -2.96, -2.49, -2.04, -1.61, -1.22, -0.87, -0.56, -0.31},
{-4.99, -4.47, -3.98, -3.51, -3.05, -2.61, -2.18, -1.77, -1.39, -1.05, -0.75, -0.5, -0.3},
{-4.99, -4.49, -4.02, -3.57, -3.13, -2.7, -2.29, -1.89, -1.52, -1.18, -0.89, -0.64, -0.44},
{-4.99, -4.49, -4.02, -3.57, -3.14, -2.72, -2.32, -1.94, -1.59, -1.27, -0.99, -0.74, -0.54, -0.38},
{-4.99, -4.49, -4.03, -3.6, -3.18, -2.78, -2.39, -2.02, -1.67, -1.35, -1.06, -0.81, -0.61, -0.45 },
{-5.08, -4.6, -4.15, -3.72, -3.3, -2.9, -2.51, -2.14, -1.8, -1.49, -1.21, -0.97, -0.77 }},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
     //Y23
        {{-4.35, -3.46, -2.52, -1.66, -0.98 },
{-4.35, -3.39, -2.43, -1.51, -0.8 },
{-5.17, -4.19, -3.17, -2.25, -1.47, -0.83 },
{-5.17, -4.16, -3.22, -2.4, -1.69, -1.07 },
{-5.58, -4.67, -3.78, -2.97, -2.26, -1.62, -1.01 },
{-5.99, -5.02, -4.11, -3.31, -2.61, -1.98, -1.41 },
{-6.08, -5.02, -4.17, -3.44, -2.78, -2.19, -1.66 },
{-6.89, -5.82, -4.93, -4.17, -3.5, -2.89, -2.33, -1.79 }},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        //BT
        {{-2.54, -2.25, -1.96, -1.67, -1.38, -1.09, -0.81, -0.55, -0.32 },
{-2.54, -2.2, -1.86, -1.53, -1.22, -0.92, -0.65, -0.4 },
{-2.54, -2.19, -1.83, -1.49, -1.18, -0.91, -0.67, -0.46 },
{-2.54, -2.18, -1.81, -1.47, -1.19, -0.95, -0.74, -0.55, -0.37 },
{-2.94, -2.56, -2.18, -1.82, -1.5, -1.22, -0.98, -0.78, -0.61, -0.46 },
{-3.35, -2.93, -2.51, -2.12, -1.77, -1.46, -1.19, -0.96, -0.77, -0.61, -0.47, -0.35 },
{-3.35, -2.9, -2.47, -2.08, -1.74, -1.45, -1.2, -0.99, -0.82, -0.67, -0.54, -0.43 },
{-3.76, -3.27, -2.8, -2.37, -2, -1.69, -1.43, -1.21, -1.02, -0.85, -0.69, -0.55, -0.41 }},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
       //RhoTT 24
        {{-5.08, -4.31, -3.7, -3.15, -2.62, -2.11, -1.63, -1.2, -0.85 },
{-5.08, -4.28, -3.68, -3.14, -2.63, -2.14, -1.68, -1.27, -0.93 },
{-5.08, -4.46, -3.92, -3.41, -2.91, -2.43, -1.98, -1.59, -1.27, -1.04, -0.89 },
{-5.08, -4.47, -3.94, -3.45, -2.98, -2.53, -2.11, -1.73, -1.41, -1.16, -0.97, -0.85 },
{-5.08, -4.52, -4.01, -3.54, -3.09, -2.66, -2.26, -1.9, -1.58, -1.31, -1.09, -0.92 },
{-5.08, -4.55, -4.06, -3.59, -3.14, -2.72, -2.33, -1.98, -1.67, -1.41, -1.2, -1.04, -0.92 },
{-5.49, -4.9, -4.38, -3.9, -3.45, -3.03, -2.64, -2.28, -1.95, -1.67, -1.43, -1.23, -1.07, -0.95 },
{-5.49, -4.96, -4.45, -3.97, -3.52, -3.11, -2.73, -2.39, -2.08, -1.8, -1.54, -1.3, -1.09, -0.89 }},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}}};


//-----------------------------------------------------------------------------------
//For charge particle
double binrngs1[nvar][nHLTmx][nmxbins+1] ={
//double binrngs1[nvar][nHLTmx][37] ={
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        //Thrust 3
        {{-5.29, -4.57, -4.1, -3.7, -3.33, -2.96, -2.59, -2.21, -1.84, -1.5, -1.22, -1 },
{-5.29, -4.65, -4.2, -3.8, -3.42, -3.03, -2.63, -2.23, -1.84, -1.49, -1.21, -1.02, -0.91 },
{-5.49, -4.9, -4.44, -4.02, -3.61, -3.19, -2.76, -2.33, -1.91, -1.54, -1.25, -1.05, -0.93 },
{-5.54, -5, -4.53, -4.09, -3.65, -3.2, -2.75, -2.31, -1.9, -1.54, -1.26, -1.06, -0.93 },
{-5.65, -5.11, -4.62, -4.15, -3.68, -3.21, -2.74, -2.28, -1.86, -1.51, -1.24, -1.06, -0.94, -0.87 },
{-5.65, -5.11, -4.59, -4.08, -3.56, -3.05, -2.55, -2.09, -1.69, -1.37, -1.13, -0.97, -0.87 },
{-5.66, -5.08, -4.52, -3.96, -3.4, -2.85, -2.33, -1.86, -1.48, -1.2, -1.02, -0.9 },
{-5.54, -4.89, -4.22, -3.54, -2.87, -2.26, -1.74, -1.33, -1.05, -0.87 }},
	{{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        //RhoT 9
        {{-5.8, -4.59, -3.69, -2.94, -2.29, -1.71, -1.19, -0.73, -0.33 },
{-5.8, -4.65, -3.81, -3.1, -2.46, -1.87, -1.33, -0.86, -0.46 },
{-5.8, -4.74, -3.98, -3.32, -2.7, -2.1, -1.54, -1.05, -0.65 },
{-6.62, -5.4, -4.55, -3.83, -3.16, -2.53, -1.93, -1.38, -0.9, -0.51 },
{-6.62, -5.43, -4.59, -3.87, -3.21, -2.58, -1.98, -1.43, -0.96, -0.58 },
{-6.62, -5.47, -4.61, -3.86, -3.16, -2.49, -1.86, -1.3, -0.83, -0.47 },
{-6.62, -5.45, -4.57, -3.79, -3.05, -2.34, -1.68, -1.11, -0.66 },
{-5.8, -4.9, -3.88, -2.95, -2.2, -1.58, -1.02, -0.46 }},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
//        {{},{},{},{},{},{},{},{}}, //extra
        //Y23 15
        {{-6.89, -5.41, -3.93, -2.62, -1.23 },
{-6.89, -5.42, -3.94, -2.67, -1.28 },
{-6.89, -5.47, -4.09, -2.88, -1.61 },
{-6.89, -5.47, -4.12, -2.94, -1.72 },
{-6.89, -5.58, -4.28, -3.09, -1.9 },
{-6.89, -5.55, -4.24, -3.02, -1.78 },
{-6.08, -4.91, -3.57, -2.32, -0.85 }, 
{-6.08, -4.91, -3.57, -2.32, -0.85 }}, 
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        //BT
        {{-3.35, -2.91, -2.56, -2.24, -1.93, -1.61, -1.29, -0.97, -0.66, -0.39 },
{-3.76, -3.23, -2.84, -2.5, -2.17, -1.83, -1.48, -1.13, -0.79, -0.49 },
{-3.76, -3.28, -2.9, -2.55, -2.2, -1.83, -1.45, -1.07, -0.73, -0.46 },
{-3.76, -3.31, -2.92, -2.55, -2.17, -1.79, -1.4, -1.03, -0.69, -0.41 },
{-4.17, -3.64, -3.19, -2.77, -2.36, -1.94, -1.53, -1.14, -0.79, -0.51 },
{-4.02, -3.51, -3.05, -2.6, -2.15, -1.7, -1.27, -0.89, -0.59, -0.38 },
{-3.79, -3.26, -2.74, -2.23, -1.74, -1.28, -0.88, -0.56, -0.32 },
{-3.57, -2.92, -2.31, -1.8, -1.36, -0.96, -0.55, -0.08 }},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        //RhoTT 24
        {{-5.49, -4.21, -3.36, -2.67, -2.07, -1.52, -1.01 },
{-5.49, -4.29, -3.52, -2.86, -2.25, -1.68, -1.19, -0.81 },
{-5.89, -4.67, -3.89, -3.22, -2.6, -2.03, -1.51, -1.08, -0.76 },
{-5.89, -4.81, -4.06, -3.4, -2.78, -2.2, -1.67, -1.23, -0.9 },
{-5.89, -4.88, -4.13, -3.46, -2.83, -2.24, -1.71, -1.27, -0.95 },
{-5.89, -4.95, -4.18, -3.48, -2.84, -2.25, -1.72, -1.27, -0.91 },
{-5.89, -4.96, -4.13, -3.38, -2.69, -2.07, -1.53, -1.07, -0.7 },
{-5.89, -4.93, -4.13, -3.43, -2.78, -2.15, -1.52, -0.86 }},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}}};




 int nbinsx[nvar]={120, 120, 120, 120, 120, 120, 
                   120, 120, 120, 120, 120, 120, 
                   120, 120, 120, 120, 120, 120, 
                   120, 120, 120, 120, 120, 120, 
                   120, 120, 120, 120, 120, 120, 
                   120, 120};



double endxt[nvar]={8.0, 8.0, 6.0, 8.0, 6.0,  5.0,
                    4.0, 4.0,  2.0, 7.0, 7.0, 4.0,
                    7.0, 7.0, 4.0, 8.0, 8.0, 6.0,
                    5.0, 5.0, 4.0, 5.0, 5.0, 4.0,
                    10.0, 10.0, 10.0, 10.0, 10.0, 10.0,
                    0.0, 0.0};
double startx[nvar]={2., 0.5, 1., 1, 0.0, 2.,
                     0., 0., 1., 0.2, -1., -1.,
                     0., 0., 1., 1.0, 2., 0.5,
                     0.2, -0.5, -1., 0., -1., -1.,
                     1.0, 0., -0.5, 0., 0., -0.5,
                    -1., -1.};
double endx[nvar]={10.0, 10.0, 10.0, 8.0, 12.0, 12.0,
                   19.0, 19.0, 10.0, 6.2, 10.0, 10.0,
                   13.0, 13.0,  10.0, 8.0, 10.0, 6.0,
                   6.0, 5.0, 5.0, 8.0, 8.0, 8.0,
                   7.0, 8.0, 8.0, 12.0, 12.0, 8.0,
                   0.0, 0.0};

//Range for each variable and range
double eendx[typen][nvar][nHLTmx]={{{},{},{},
                   {8,8,8,8,8,8,8,8},//3
                   {},{},{},{},{},
                   {6,6,6,6,6,6,6,6},//9
                   {},{},{},{},{},
                   {5,5,6,6,6.5,7,7,8},//15
                   {},{},
                   {3,3,3,3,3.5,4,4,4.5},//18
                   {},{},{},{},{},
                   {6,6,6,6,6,6,6.5,6.5},//24
                   {},{},{},{},{},{},{}},
                   //charge
                   {{},{},{},
                   {7,7,7,7.5,7.5,7.5,8,8},//3
                   {},{},{},{},{},
                   {7,7,7,8,8,8,8,7},//9
                   {},{},{},{},{},
                   {8,8,8,8,8,8,7,7},//15
                   {},{},
                   {4,4.5,4.5,4.5,5,5,5,5},//18
                   {},{},{},{},{},
                   {6.5,6.5,7,7,7,7,7,7},//24
                   {},{},{},{},{},{},{}}};

double estartx[typen][nvar][nHLTmx]={{{},{},{},
                   {1,1,1,1,1,1,1,1},//3
                   {},{},{},{},{},
                   {0.5,0.5,0.5,0.5,0.5,0.5,0.5,1.0},//9
                   {},{},{},{},{},
                   {1.5,1.5,1.5,1.5,1.5,1.5,2.0,2.0},//15
                   {},{},
                   {0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5},//18
                   {},{},{},{},{},
                   {1,1,1,1,1,1,1,1},//24
                   {},{},{},{},{},{},{}},
                   //charhe
                   {{},{},{},
                   {1,1,1,1,1,1,1,1},//3
                   {},{},{},{},{},
                   {.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5},//9
                   {},{},{},{},{},
                   {2,2,2,2,2,2,2,2},//15
                   {},{},
                   {0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5},//18
                   {},{},{},{},{},
                   {1,1,1,1,1,1,1,1},//24
                   {},{},{},{},{},{},{}}};


//----------------------for reco rebin
static const int  rnmxbins =36;
int rnbinsx0[nvar][nHLTmx]={{},{},{},
                   {26,26,26,30,30,34,32,36},//3
                   {},{},{},{},{},
                   {20,20,22,24,24,26,26,24},//9
                   {},{},{},{},{},
                   {8,8,10,10,12,12,12,14},//15
                   {},{},
                   {16,14,14,16,18,22,22,24},//18
                   {},{},{},{},{},
                   {16,16,20,22,22,24,26,26},//24
                   {},{},{},{},{},{},{}};

//For charge Particles
int rnbinsx1[nvar][nHLTmx]={{},{},{},
                   {22,24,24,24,26,24,22,18},//3
                   {},{},{},{},{},
                   {16,16,16,16,18,18,16,14},//9
                   {},{},{},{},{},
                   {8,8,8,8,8,8,8,8},//15
                   {},{},
                   {18,18,18,18,18,18,16,14},//18
                   {},{},{},{},{},
                   {12,14,16,16,16,16,16,14},//24
                   {},{},{},{},{},{},{}};
///////////////////Modify /////////////////////////////
//for Jets
double rbinrngs0[nvar][nHLTmx][rnmxbins+1] ={
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        //Thrust 3
        {{-6.71,-6.29,-5.87,-5.525,-5.18,-4.885,-4.59,-4.33,-4.07,-3.835,-3.6,-3.385,-3.17,-2.97,-2.77,-2.585,-2.4,-2.225,-2.05,-1.89,-1.73,-1.58,-1.43,-1.295,-1.16,-1.035,-0.91},
{-6.71,-6.235,-5.76,-5.425,-5.09,-4.81,-4.53,-4.285,-4.04,-3.81,-3.58,-3.365,-3.15,-2.945,-2.74,-2.545,-2.35,-2.165,-1.98,-1.815,-1.65,-1.505,-1.36,-1.24,-1.12,-1.02,-0.92},
{-6.71,-6.245,-5.78,-5.46,-5.14,-4.875,-4.61,-4.375,-4.14,-3.92,-3.7,-3.49,-3.28,-3.075,-2.87,-2.675,-2.48,-2.295,-2.11,-1.94,-1.77,-1.62,-1.47,-1.345,-1.22,-1.12,-1.02},
{-6.71,-6.325,-5.94,-5.635,-5.33,-5.065,-4.8,-4.56,-4.32,-4.095,-3.87,-3.655,-3.44,-3.235,-3.03,-2.835,-2.64,-2.46,-2.28,-2.11,-1.94,-1.79,-1.64,-1.51,-1.38,-1.27,-1.16,-1.065,-0.97,-0.895,-0.82},
{-6.71,-6.35,-5.99,-5.695,-5.4,-5.14,-4.88,-4.64,-4.4,-4.175,-3.95,-3.735,-3.52,-3.315,-3.11,-2.915,-2.72,-2.54,-2.36,-2.195,-2.03,-1.885,-1.74,-1.61,-1.48,-1.375,-1.27,-1.185,-1.1,-1.03,-0.96},
{-6.71,-6.375,-6.04,-5.75,-5.46,-5.2,-4.94,-4.7,-4.46,-4.23,-4,-3.785,-3.57,-3.365,-3.16,-2.965,-2.77,-2.59,-2.41,-2.25,-2.09,-1.945,-1.8,-1.675,-1.55,-1.45,-1.35,-1.265,-1.18,-1.115,-1.05,-1,-0.95,-0.91,-0.87},
{-6.71,-6.375,-6.04,-5.745,-5.45,-5.185,-4.92,-4.675,-4.43,-4.2,-3.97,-3.755,-3.54,-3.34,-3.14,-2.955,-2.77,-2.6,-2.43,-2.275,-2.12,-1.98,-1.84,-1.72,-1.6,-1.495,-1.39,-1.3,-1.21,-1.135,-1.06,-1,-0.94},
{-6.71,-6.385,-6.06,-5.77,-5.48,-5.215,-4.95,-4.705,-4.46,-4.23,-4,-3.785,-3.57,-3.375,-3.18,-3,-2.82,-2.655,-2.49,-2.345,-2.2,-2.07,-1.94,-1.825,-1.71,-1.61,-1.51,-1.425,-1.34,-1.27,-1.2,-1.145,-1.09,-1.045,-1,-0.96,-0.92}},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        //RhoT 9
        {{-4.99,-4.715,-4.44,-4.165,-3.89,-3.62,-3.35,-3.085,-2.82,-2.56,-2.3,-2.055,-1.81,-1.58,-1.35,-1.14,-0.93,-0.745,-0.56,-0.4,-0.24},
{-4.99,-4.71,-4.43,-4.155,-3.88,-3.615,-3.35,-3.09,-2.83,-2.58,-2.33,-2.09,-1.85,-1.625,-1.4,-1.195,-0.99,-0.805,-0.62,-0.455,-0.29},
{-4.99,-4.715,-4.44,-4.185,-3.93,-3.685,-3.44,-3.2,-2.96,-2.725,-2.49,-2.265,-2.04,-1.825,-1.61,-1.415,-1.22,-1.045,-0.87,-0.715,-0.56,-0.435,-0.31},
{-4.99,-4.73,-4.47,-4.225,-3.98,-3.745,-3.51,-3.28,-3.05,-2.83,-2.61,-2.395,-2.18,-1.975,-1.77,-1.58,-1.39,-1.22,-1.05,-0.9,-0.75,-0.625,-0.5,-0.4,-0.3},
{-4.99,-4.74,-4.49,-4.255,-4.02,-3.795,-3.57,-3.35,-3.13,-2.915,-2.7,-2.495,-2.29,-2.09,-1.89,-1.705,-1.52,-1.35,-1.18,-1.035,-0.89,-0.765,-0.64,-0.54,-0.44},
{-4.99,-4.74,-4.49,-4.255,-4.02,-3.795,-3.57,-3.355,-3.14,-2.93,-2.72,-2.52,-2.32,-2.13,-1.94,-1.765,-1.59,-1.43,-1.27,-1.13,-0.99,-0.865,-0.74,-0.64,-0.54,-0.46,-0.38},
{-4.99,-4.74,-4.49,-4.26,-4.03,-3.815,-3.6,-3.39,-3.18,-2.98,-2.78,-2.585,-2.39,-2.205,-2.02,-1.845,-1.67,-1.51,-1.35,-1.205,-1.06,-0.935,-0.81,-0.71,-0.61,-0.53,-0.45},
{-5.08,-4.84,-4.6,-4.375,-4.15,-3.935,-3.72,-3.51,-3.3,-3.1,-2.9,-2.705,-2.51,-2.325,-2.14,-1.97,-1.8,-1.645,-1.49,-1.35,-1.21,-1.09,-0.97,-0.87,-0.77}},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
     //Y23
        {{-4.35,-3.905,-3.46,-2.99,-2.52,-2.09,-1.66,-1.32,-0.98},
{-4.35,-3.87,-3.39,-2.91,-2.43,-1.97,-1.51,-1.155,-0.8},
{-5.17,-4.68,-4.19,-3.68,-3.17,-2.71,-2.25,-1.86,-1.47,-1.15,-0.83},
{-5.17,-4.665,-4.16,-3.69,-3.22,-2.81,-2.4,-2.045,-1.69,-1.38,-1.07},
{-5.58,-5.125,-4.67,-4.225,-3.78,-3.375,-2.97,-2.615,-2.26,-1.94,-1.62,-1.315,-1.01},
{-5.99,-5.505,-5.02,-4.565,-4.11,-3.71,-3.31,-2.96,-2.61,-2.295,-1.98,-1.695,-1.41},
{-6.08,-5.55,-5.02,-4.595,-4.17,-3.805,-3.44,-3.11,-2.78,-2.485,-2.19,-1.925,-1.66},
{-6.89,-6.355,-5.82,-5.375,-4.93,-4.55,-4.17,-3.835,-3.5,-3.195,-2.89,-2.61,-2.33,-2.06,-1.79}},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        //BT
        {{-2.54,-2.395,-2.25,-2.105,-1.96,-1.815,-1.67,-1.525,-1.38,-1.235,-1.09,-0.95,-0.81,-0.68,-0.55,-0.435,-0.32},
{-2.54,-2.37,-2.2,-2.03,-1.86,-1.695,-1.53,-1.375,-1.22,-1.07,-0.92,-0.785,-0.65,-0.525,-0.4},
{-2.54,-2.365,-2.19,-2.01,-1.83,-1.66,-1.49,-1.335,-1.18,-1.045,-0.91,-0.79,-0.67,-0.565,-0.46},
{-2.54,-2.36,-2.18,-1.995,-1.81,-1.64,-1.47,-1.33,-1.19,-1.07,-0.95,-0.845,-0.74,-0.645,-0.55,-0.46,-0.37},
{-2.94,-2.75,-2.56,-2.37,-2.18,-2,-1.82,-1.66,-1.5,-1.36,-1.22,-1.1,-0.98,-0.88,-0.78,-0.695,-0.61,-0.535,-0.46},
{-3.35,-3.14,-2.93,-2.72,-2.51,-2.315,-2.12,-1.945,-1.77,-1.615,-1.46,-1.325,-1.19,-1.075,-0.96,-0.865,-0.77,-0.69,-0.61,-0.54,-0.47,-0.41,-0.35},
{-3.35,-3.125,-2.9,-2.685,-2.47,-2.275,-2.08,-1.91,-1.74,-1.595,-1.45,-1.325,-1.2,-1.095,-0.99,-0.905,-0.82,-0.745,-0.67,-0.605,-0.54,-0.485,-0.43},
{-3.76,-3.515,-3.27,-3.035,-2.8,-2.585,-2.37,-2.185,-2,-1.845,-1.69,-1.56,-1.43,-1.32,-1.21,-1.115,-1.02,-0.935,-0.85,-0.77,-0.69,-0.62,-0.55,-0.48,-0.41}},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
       //RhoTT 24
        {{-5.08,-4.695,-4.31,-4.005,-3.7,-3.425,-3.15,-2.885,-2.62,-2.365,-2.11,-1.87,-1.63,-1.415,-1.2,-1.025,-0.85},
{-5.08,-4.68,-4.28,-3.98,-3.68,-3.41,-3.14,-2.885,-2.63,-2.385,-2.14,-1.91,-1.68,-1.475,-1.27,-1.1,-0.93},
{-5.08,-4.77,-4.46,-4.19,-3.92,-3.665,-3.41,-3.16,-2.91,-2.67,-2.43,-2.205,-1.98,-1.785,-1.59,-1.43,-1.27,-1.155,-1.04,-0.965,-0.89},
{-5.08,-4.775,-4.47,-4.205,-3.94,-3.695,-3.45,-3.215,-2.98,-2.755,-2.53,-2.32,-2.11,-1.92,-1.73,-1.57,-1.41,-1.285,-1.16,-1.065,-0.97,-0.91,-0.85},
{-5.08,-4.8,-4.52,-4.265,-4.01,-3.775,-3.54,-3.315,-3.09,-2.875,-2.66,-2.46,-2.26,-2.08,-1.9,-1.74,-1.58,-1.445,-1.31,-1.2,-1.09,-1.005,-0.92},
{-5.08,-4.815,-4.55,-4.305,-4.06,-3.825,-3.59,-3.365,-3.14,-2.93,-2.72,-2.525,-2.33,-2.155,-1.98,-1.825,-1.67,-1.54,-1.41,-1.305,-1.2,-1.12,-1.04,-0.98,-0.92},
{-5.49,-5.195,-4.9,-4.64,-4.38,-4.14,-3.9,-3.675,-3.45,-3.24,-3.03,-2.835,-2.64,-2.46,-2.28,-2.115,-1.95,-1.81,-1.67,-1.55,-1.43,-1.33,-1.23,-1.15,-1.07,-1.01,-0.95},
{-5.49,-5.225,-4.96,-4.705,-4.45,-4.21,-3.97,-3.745,-3.52,-3.315,-3.11,-2.92,-2.73,-2.56,-2.39,-2.235,-2.08,-1.94,-1.8,-1.67,-1.54,-1.42,-1.3,-1.195,-1.09,-0.99,-0.89}},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}}};


//-----------------------------------------------------------------------------------
//For charge particle
double rbinrngs1[nvar][nHLTmx][rnmxbins+1] ={
//double binrngs1[nvar][nHLTmx][37] ={
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        //Thrust 3 
       {{-5.29,-4.93,-4.57,-4.335,-4.1,-3.9,-3.7,-3.515,-3.33,-3.145,-2.96,-2.775,-2.59,-2.4,-2.21,-2.025,-1.84,-1.67,-1.5,-1.36,-1.22,-1.11,-1},
{-5.29,-4.97,-4.65,-4.425,-4.2,-4,-3.8,-3.61,-3.42,-3.225,-3.03,-2.83,-2.63,-2.43,-2.23,-2.035,-1.84,-1.665,-1.49,-1.35,-1.21,-1.115,-1.02,-0.965,-0.91},
{-5.49,-5.195,-4.9,-4.67,-4.44,-4.23,-4.02,-3.815,-3.61,-3.4,-3.19,-2.975,-2.76,-2.545,-2.33,-2.12,-1.91,-1.725,-1.54,-1.395,-1.25,-1.15,-1.05,-0.99,-0.93},
{-5.54,-5.27,-5,-4.765,-4.53,-4.31,-4.09,-3.87,-3.65,-3.425,-3.2,-2.975,-2.75,-2.53,-2.31,-2.105,-1.9,-1.72,-1.54,-1.4,-1.26,-1.16,-1.06,-0.995,-0.93},
{-5.65,-5.38,-5.11,-4.865,-4.62,-4.385,-4.15,-3.915,-3.68,-3.445,-3.21,-2.975,-2.74,-2.51,-2.28,-2.07,-1.86,-1.685,-1.51,-1.375,-1.24,-1.15,-1.06,-1,-0.94,-0.905,-0.87},
{-5.65,-5.38,-5.11,-4.85,-4.59,-4.335,-4.08,-3.82,-3.56,-3.305,-3.05,-2.8,-2.55,-2.32,-2.09,-1.89,-1.69,-1.53,-1.37,-1.25,-1.13,-1.05,-0.97,-0.92,-0.87},
{-5.66,-5.37,-5.08,-4.8,-4.52,-4.24,-3.96,-3.68,-3.4,-3.125,-2.85,-2.59,-2.33,-2.095,-1.86,-1.67,-1.48,-1.34,-1.2,-1.11,-1.02,-0.96,-0.9},
{-5.54,-5.215,-4.89,-4.555,-4.22,-3.88,-3.54,-3.205,-2.87,-2.565,-2.26,-2,-1.74,-1.535,-1.33,-1.19,-1.05,-0.96,-0.87}},
	{{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        //RhoT 9
  {{-5.8,-5.195,-4.59,-4.14,-3.69,-3.315,-2.94,-2.615,-2.29,-2,-1.71,-1.45,-1.19,-0.96,-0.73,-0.53,-0.33},
{-5.8,-5.225,-4.65,-4.23,-3.81,-3.455,-3.1,-2.78,-2.46,-2.165,-1.87,-1.6,-1.33,-1.095,-0.86,-0.66,-0.46},
{-5.8,-5.27,-4.74,-4.36,-3.98,-3.65,-3.32,-3.01,-2.7,-2.4,-2.1,-1.82,-1.54,-1.295,-1.05,-0.85,-0.65},
{-6.62,-6.01,-5.4,-4.975,-4.55,-4.19,-3.83,-3.495,-3.16,-2.845,-2.53,-2.23,-1.93,-1.655,-1.38,-1.14,-0.9},
{-6.62,-6.025,-5.43,-5.01,-4.59,-4.23,-3.87,-3.54,-3.21,-2.895,-2.58,-2.28,-1.98,-1.705,-1.43,-1.195,-0.96,-0.77,-0.58},
{-6.62,-6.045,-5.47,-5.04,-4.61,-4.235,-3.86,-3.51,-3.16,-2.825,-2.49,-2.175,-1.86,-1.58,-1.3,-1.065,-0.83,-0.65,-0.47},
{-6.62,-6.035,-5.45,-5.01,-4.57,-4.18,-3.79,-3.42,-3.05,-2.695,-2.34,-2.01,-1.68,-1.395,-1.11,-0.885,-0.66},
{-5.8,-5.35,-4.9,-4.39,-3.88,-3.415,-2.95,-2.575,-2.2,-1.89,-1.58,-1.3,-1.02,-0.74,-0.46}},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
//        {{},{},{},{},{},{},{},{}}, //extra
        //Y23 15
        {{-6.89,-6.15,-5.41,-4.67,-3.93,-3.275,-2.62,-1.925,-1.23},
{-6.89,-6.155,-5.42,-4.68,-3.94,-3.305,-2.67,-1.975,-1.28},
{-6.89,-6.18,-5.47,-4.78,-4.09,-3.485,-2.88,-2.245,-1.61},
{-6.89,-6.18,-5.47,-4.795,-4.12,-3.53,-2.94,-2.33,-1.72},
{-6.89,-6.235,-5.58,-4.93,-4.28,-3.685,-3.09,-2.495,-1.9},
{-6.89,-6.22,-5.55,-4.895,-4.24,-3.63,-3.02,-2.4,-1.78},
{-6.08,-5.495,-4.91,-4.24,-3.57,-2.945,-2.32,-1.585,-0.85},
{-6.08,-5.495,-4.91,-4.24,-3.57,-2.945,-2.32,-1.585,-0.85}}, 
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        //BT
    {{-3.35,-3.13,-2.91,-2.735,-2.56,-2.4,-2.24,-2.085,-1.93,-1.77,-1.61,-1.45,-1.29,-1.13,-0.97,-0.815,-0.66,-0.525,-0.39},
{-3.76,-3.495,-3.23,-3.035,-2.84,-2.67,-2.5,-2.335,-2.17,-2,-1.83,-1.655,-1.48,-1.305,-1.13,-0.96,-0.79,-0.64,-0.49},
{-3.76,-3.52,-3.28,-3.09,-2.9,-2.725,-2.55,-2.375,-2.2,-2.015,-1.83,-1.64,-1.45,-1.26,-1.07,-0.9,-0.73,-0.595,-0.46},
{-3.76,-3.535,-3.31,-3.115,-2.92,-2.735,-2.55,-2.36,-2.17,-1.98,-1.79,-1.595,-1.4,-1.215,-1.03,-0.86,-0.69,-0.55,-0.41},
{-4.17,-3.905,-3.64,-3.415,-3.19,-2.98,-2.77,-2.565,-2.36,-2.15,-1.94,-1.735,-1.53,-1.335,-1.14,-0.965,-0.79,-0.65,-0.51},
{-4.02,-3.765,-3.51,-3.28,-3.05,-2.825,-2.6,-2.375,-2.15,-1.925,-1.7,-1.485,-1.27,-1.08,-0.89,-0.74,-0.59,-0.485,-0.38},
{-3.79,-3.525,-3.26,-3,-2.74,-2.485,-2.23,-1.985,-1.74,-1.51,-1.28,-1.08,-0.88,-0.72,-0.56,-0.44,-0.32},
{-3.57,-3.245,-2.92,-2.615,-2.31,-2.055,-1.8,-1.58,-1.36,-1.16,-0.96,-0.755,-0.55,-0.315,-0.08}},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        //RhoTT 24
        {{-5.49,-4.85,-4.21,-3.785,-3.36,-3.015,-2.67,-2.37,-2.07,-1.795,-1.52,-1.265,-1.01},
{-5.49,-4.89,-4.29,-3.905,-3.52,-3.19,-2.86,-2.555,-2.25,-1.965,-1.68,-1.435,-1.19,-1,-0.81},
{-5.89,-5.28,-4.67,-4.28,-3.89,-3.555,-3.22,-2.91,-2.6,-2.315,-2.03,-1.77,-1.51,-1.295,-1.08,-0.92,-0.76},
{-5.89,-5.35,-4.81,-4.435,-4.06,-3.73,-3.4,-3.09,-2.78,-2.49,-2.2,-1.935,-1.67,-1.45,-1.23,-1.065,-0.9},
{-5.89,-5.385,-4.88,-4.505,-4.13,-3.795,-3.46,-3.145,-2.83,-2.535,-2.24,-1.975,-1.71,-1.49,-1.27,-1.11,-0.95},
{-5.89,-5.42,-4.95,-4.565,-4.18,-3.83,-3.48,-3.16,-2.84,-2.545,-2.25,-1.985,-1.72,-1.495,-1.27,-1.09,-0.91},
{-5.89,-5.425,-4.96,-4.545,-4.13,-3.755,-3.38,-3.035,-2.69,-2.38,-2.07,-1.8,-1.53,-1.3,-1.07,-0.885,-0.7},
{-5.89,-5.41,-4.93,-4.53,-4.13,-3.78,-3.43,-3.105,-2.78,-2.465,-2.15,-1.835,-1.52,-1.19,-0.86}},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}},
        {{},{},{},{},{},{},{},{}}};



const int nusedvar=5;
double usedvars[nusedvar]={3, 9, 15, 18, 24};

int isItUsed(int ival) {
	for (int ij=0; ij<nusedvar; ij++) {
		if (ival==usedvars[ij]) {return 1;}
	}
	return 0;
} 


const int npileupmx=99; //49;
double rat_pileup[nHLTmx][npileupmx]={{0}};
//clock_t t1,t2;


//MC Ultra Legacy : mix_2018_25ns_UltraLegacy_PoissonOOTPU_cfi.py

double mcpileup[npileupmx] ={8.89374611122e-07, 1.1777062868e-05, 3.99725585118e-05, 0.000129888015252, 0.000265224848687,
    0.000313088635109, 0.000353781668514, 0.000508787237162, 0.000873670065767, 0.00147166880932,
    0.00228230649018, 0.00330375581273, 0.00466047608406, 0.00624959203029, 0.00810375867901,
    0.010306521821, 0.0129512453978, 0.0160303925502, 0.0192913204592, 0.0223108613632,
    0.0249798930986, 0.0273973789867, 0.0294402350483, 0.031029854302, 0.0324583524255,
    0.0338264469857, 0.0351267479019, 0.0360320204259, 0.0367489568401, 0.0374133183052,
    0.0380352633799, 0.0386200967002, 0.039124376968, 0.0394201612616, 0.0394673457109,
    0.0391705388069, 0.0384758587461, 0.0372984548399, 0.0356497876549, 0.0334655175178,
    0.030823567063, 0.0278340752408, 0.0246009685048, 0.0212676009273, 0.0180250593982,
    0.0149129830776, 0.0120582333486, 0.00953400069415, 0.00738546929512, 0.00563442079939,
    0.00422052915668, 0.00312446316347, 0.00228717533955, 0.00164064894334, 0.00118425084792,
    0.000847785826565, 0.000603466454784, 0.000419347268964, 0.000291768785963, 0.000199761337863,
    0.000136624574661, 9.46855200945e-05, 6.80243180179e-05, 4.94806013765e-05, 3.53122628249e-05,
    2.556765786e-05, 1.75845711623e-05, 1.23828210848e-05, 9.31669724108e-06, 6.0713272037e-06,
    3.95387384933e-06, 2.02760874107e-06, 1.22535149516e-06, 9.79612472109e-07, 7.61730246474e-07,
    4.2748847738e-07, 2.41170461205e-07, 1.38701083552e-07, 3.37678010922e-08, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0};
//PileUP : mix_2018_25ns_JuneProjectionFull18_PoissonOOTPU_cfi.py
/*
double mcpileup[npileupmx] ={ 4.695341e-10, 1.206213e-06, 1.162593e-06, 6.118058e-06, 1.626767e-05,
    3.508135e-05, 7.12608e-05, 0.0001400641, 0.0002663403, 0.0004867473,
    0.0008469, 0.001394142, 0.002169081, 0.003198514, 0.004491138,
    0.006036423, 0.007806509, 0.00976048, 0.0118498, 0.01402411,
    0.01623639, 0.01844593, 0.02061956, 0.02273221, 0.02476554,
    0.02670494, 0.02853662, 0.03024538, 0.03181323, 0.03321895,
    0.03443884, 0.035448, 0.03622242, 0.03674106, 0.0369877,
    0.03695224, 0.03663157, 0.03602986, 0.03515857, 0.03403612,
    0.0326868, 0.03113936, 0.02942582, 0.02757999, 0.02563551,
    0.02362497, 0.02158003, 0.01953143, 0.01750863, 0.01553934,
    0.01364905, 0.01186035, 0.01019246, 0.008660705, 0.007275915,
    0.006043917, 0.004965276, 0.004035611, 0.003246373, 0.002585932,
    0.002040746, 0.001596402, 0.001238498, 0.0009533139, 0.0007282885,
    0.000552306, 0.0004158005, 0.0003107302, 0.0002304612, 0.0001696012,
    0.0001238161, 8.96531e-05, 6.438087e-05, 4.585302e-05, 3.23949e-05,
    2.271048e-05, 1.580622e-05, 1.09286e-05, 7.512748e-06, 5.140304e-06,
    3.505254e-06, 2.386437e-06, 1.625859e-06, 1.111865e-06, 7.663272e-07,
    5.350694e-07, 3.808318e-07, 2.781785e-07, 2.098661e-07, 1.642811e-07,
    1.312835e-07, 1.081326e-07, 9.141993e-08, 7.890983e-08, 6.91468e-08,
    6.119019e-08, 5.443693e-08, 4.85036e-08, 4.31486e-08, 3.822112e-08};
*/

//HLT Path PileUP ReReco : Cert_314472-325175_13TeV_17SeptEarlyReReco2018ABC_PromptEraD_Collisions18_JSON.txt

double datpileup[nHLTmx][npileupmx] ={{6.89371e-06, 2.40471e-05, 7.48654e-05, 0.000166813, 0.000286186, 0.000441025, 0.000652633, 0.000932016, 0.00129358, 0.00178302, 0.00247083, 0.00342066, 0.00469732, 0.00635962, 0.00845033, 0.0110021, 0.0140263, 0.0174796, 0.021228, 0.0250336, 0.028584, 0.0315723, 0.0338013, 0.0352523, 0.0360623, 0.0364353, 0.0365644, 0.0365948, 0.0366152, 0.0366598, 0.0367181, 0.0367512, 0.0367067, 0.0365292, 0.0361634, 0.035558, 0.0346681, 0.0334588, 0.0319094, 0.0300179, 0.027808, 0.0253311, 0.0226636, 0.0199005, 0.0171436, 0.0144902, 0.0120225, 0.00980054, 0.00786001, 0.00621239, 0.00484896, 0.00374617, 0.00287149, 0.00218879, 0.00166232, 0.00125967, 0.000953136, 0.000720108, 0.000542873, 0.000407904, 0.000305042, 0.000226703, 0.000167203, 0.000122231, 8.84772e-05, 6.33629e-05, 4.48652e-05, 3.13927e-05, 2.1697e-05, 1.48065e-05, 9.97287e-06, 6.62745e-06, 4.34376e-06, 2.80682e-06, 1.78741e-06, 1.12133e-06, 6.92752e-07, 4.21316e-07, 2.52162e-07, 1.48477e-07, 8.59853e-08, 4.89625e-08, 2.74079e-08, 1.5079e-08, 8.15214e-09, 4.33014e-09, 2.25943e-09, 1.15799e-09, 5.82867e-10, 2.88102e-10, 1.39829e-10, 6.66319e-11, 3.11725e-11, 1.43165e-11, 6.45436e-12, 2.85627e-12, 1.24069e-12, 5.28975e-13, 2.21378e-13},
{2.92287e-06, 1.1166e-05, 3.92603e-05, 8.50284e-05, 0.000150624, 0.000230675, 0.000342694, 0.000510896, 0.000725779, 0.00100985, 0.00142668, 0.00204508, 0.00292472, 0.00410804, 0.00562153, 0.0074872, 0.00970768, 0.0122379, 0.0149737, 0.0177645, 0.0204417, 0.0228579, 0.0249331, 0.0266785, 0.0281807, 0.0295563, 0.0309044, 0.0322775, 0.0336725, 0.0350428, 0.0363191, 0.0374312, 0.0383214, 0.0389473, 0.0392771, 0.0392839, 0.0389417, 0.0382258, 0.0371173, 0.0356094, 0.0337142, 0.0314665, 0.0289254, 0.0261697, 0.023292, 0.0203901, 0.0175571, 0.0148738, 0.0124032, 0.0101869, 0.00824543, 0.00658121, 0.00518243, 0.00402764, 0.00308979, 0.00233973, 0.00174865, 0.00128952, 0.00093803, 0.000672878, 0.000475861, 0.000331726, 0.00022794, 0.0001544, 0.000103126, 6.79418e-05, 4.41741e-05, 2.83592e-05, 1.79874e-05, 1.12778e-05, 6.99323e-06, 4.29026e-06, 2.6046e-06, 1.56487e-06, 9.30366e-07, 5.47218e-07, 3.183e-07, 1.83013e-07, 1.0396e-07, 5.83113e-08, 3.22775e-08, 1.76228e-08, 9.48553e-09, 5.03111e-09, 2.62847e-09, 1.35215e-09, 6.8468e-10, 3.41174e-10, 1.67256e-10, 8.06524e-11, 3.82472e-11, 1.78345e-11, 8.17587e-12, 3.6844e-12, 1.63196e-12, 7.10439e-13, 3.03944e-13, 1.27799e-13, 5.28216e-14},
{1.02097e-05, 3.52731e-05, 0.00010551, 0.000230089, 0.000392915, 0.000606428, 0.000895809, 0.00128284, 0.00178879, 0.00246249, 0.00338826, 0.00464788, 0.00630385, 0.008395, 0.0109426, 0.0139584, 0.0174287, 0.0212803, 0.0253468, 0.0293619, 0.0329962, 0.0359426, 0.038011, 0.0391861, 0.0396097, 0.0395073, 0.0391098, 0.0385994, 0.0380838, 0.0375996, 0.0371311, 0.0366369, 0.0360682, 0.0353765, 0.0345142, 0.0334356, 0.0321007, 0.0304826, 0.0285736, 0.026391, 0.023978, 0.0214009, 0.0187432, 0.016095, 0.0135435, 0.0111642, 0.00901468, 0.0071314, 0.00552969, 0.00420585, 0.00314109, 0.00230646, 0.00166768, 0.00118935, 0.000838103, 0.000584512, 0.000404051, 0.000277148, 0.000188763, 0.000127688, 8.57662e-05, 5.71709e-05, 3.77915e-05, 2.47522e-05, 1.60508e-05, 1.02984e-05, 6.5349e-06, 4.10023e-06, 2.54366e-06, 1.56044e-06, 9.46821e-07, 5.68381e-07, 3.37657e-07, 1.98547e-07, 1.1557e-07, 6.65905e-08, 3.7975e-08, 2.1428e-08, 1.19591e-08, 6.59859e-09, 3.59763e-09, 1.93715e-09, 1.02958e-09, 5.39863e-10, 2.79139e-10, 1.42258e-10, 7.14288e-11, 3.53226e-11, 1.71978e-11, 8.24154e-12, 3.88642e-12, 1.80303e-12, 8.2279e-13, 3.69278e-13, 1.62996e-13, 7.0763e-14, 3.02299e-14, 1.2723e-14, 5.29089e-15},
{1.01281e-05, 3.50002e-05, 0.00010477, 0.000228591, 0.000390302, 0.000602288, 0.000889853, 0.00127465, 0.00177781, 0.00244821, 0.00337008, 0.00462475, 0.00627437, 0.00835805, 0.0108974, 0.0139043, 0.0173653, 0.0212072, 0.0252647, 0.0292724, 0.0329024, 0.0358484, 0.0379207, 0.0391037, 0.0395378, 0.0394468, 0.0390601, 0.0385584, 0.0380493, 0.0375692, 0.0371036, 0.0366121, 0.0360472, 0.0353611, 0.0345066, 0.0334378, 0.0321141, 0.0305079, 0.0286109, 0.0264398, 0.0240372, 0.0214695, 0.0188195, 0.0161772, 0.0136296, 0.0112521, 0.00910211, 0.00721629, 0.00561018, 0.00428046, 0.00320874, 0.00236654, 0.00171998, 0.00123401, 0.000875519, 0.000615288, 0.0004289, 0.000296841, 0.000204079, 0.000139372, 9.45086e-05, 6.35848e-05, 4.24055e-05, 2.8007e-05, 1.83029e-05, 1.18277e-05, 7.55474e-06, 4.76872e-06, 2.97484e-06, 1.83441e-06, 1.11854e-06, 6.74675e-07, 4.02716e-07, 2.3796e-07, 1.3922e-07, 8.06523e-08, 4.62607e-08, 2.62652e-08, 1.47556e-08, 8.19846e-09, 4.50262e-09, 2.44286e-09, 1.30849e-09, 6.91552e-10, 3.6043e-10, 1.85155e-10, 9.37051e-11, 4.67006e-11, 2.29114e-11, 1.10613e-11, 5.2537e-12, 2.45425e-12, 1.1274e-12, 5.09183e-13, 2.26082e-13, 9.86888e-14, 4.23639e-14, 1.78978e-14, 7.45677e-15},
{1.03188e-05, 3.559e-05, 0.000107469, 0.000235101, 0.000400513, 0.000615241, 0.000902661, 0.00127906, 0.00176071, 0.0023923, 0.00325867, 0.00444482, 0.00602085, 0.00804108, 0.0105476, 0.0135718, 0.0171113, 0.0210885, 0.0253158, 0.0294954, 0.0332657, 0.0362944, 0.0383761, 0.0394876, 0.0397706, 0.0394603, 0.0388104, 0.0380377, 0.0372889, 0.0366315, 0.0360644, 0.0355423, 0.0350005, 0.0343724, 0.0335992, 0.0326339, 0.0314426, 0.0300054, 0.0283154, 0.0263805, 0.0242246, 0.0218904, 0.0194379, 0.0169408, 0.0144792, 0.0121308, 0.00996246, 0.00802319, 0.00634156, 0.0049256, 0.00376538, 0.00283802, 0.00211297, 0.00155683, 0.00113699, 0.00082412, 0.000593325, 0.000424404, 0.000301546, 0.000212689, 0.00014879, 0.000103136, 7.07691e-05, 4.80324e-05, 3.22279e-05, 2.13697e-05, 1.40023e-05, 9.06778e-06, 5.80544e-06, 3.67606e-06, 2.30323e-06, 1.4285e-06, 8.773e-07, 5.33601e-07, 3.2143e-07, 1.91725e-07, 1.13199e-07, 6.61255e-08, 3.81942e-08, 2.17993e-08, 1.22859e-08, 6.83273e-09, 3.74731e-09, 2.02544e-09, 1.07832e-09, 5.65187e-10, 2.91513e-10, 1.47903e-10, 7.37911e-11, 3.61919e-11, 1.74458e-11, 8.26325e-12, 3.84514e-12, 1.75756e-12, 7.89038e-13, 3.47893e-13, 1.50647e-13, 6.40797e-14, 2.6789e-14},
{1.03618e-05, 3.57365e-05, 0.000107901, 0.000236049, 0.000402124, 0.000617711, 0.000906239, 0.00128405, 0.00176747, 0.00240128, 0.00327045, 0.00446012, 0.00604041, 0.00806559, 0.0105778, 0.0136086, 0.0171559, 0.0211425, 0.0253811, 0.0295733, 0.0333565, 0.0363974, 0.0384892, 0.039608, 0.0398948, 0.0395852, 0.0389333, 0.0381565, 0.037402, 0.0367373, 0.0361613, 0.0356282, 0.0350726, 0.0344276, 0.0336344, 0.0326464, 0.0314307, 0.0299685, 0.0282541, 0.0262965, 0.0241208, 0.0217702, 0.0193055, 0.0168009, 0.0143365, 0.0119898, 0.00982689, 0.00789621, 0.00622546, 0.00482173, 0.00367442, 0.00276007, 0.00204766, 0.00150336, 0.00109428, 0.000790864, 0.000568097, 0.000405769, 0.000288144, 0.000203303, 0.000142385, 9.88745e-05, 6.80015e-05, 4.6275e-05, 3.1135e-05, 2.07025e-05, 1.36014e-05, 8.83005e-06, 5.66586e-06, 3.59467e-06, 2.25596e-06, 1.40109e-06, 8.61414e-07, 5.24389e-07, 3.16087e-07, 1.8863e-07, 1.11411e-07, 6.50969e-08, 3.76064e-08, 2.14662e-08, 1.20991e-08, 6.72913e-09, 3.6906e-09, 1.99481e-09, 1.06203e-09, 5.56649e-10, 2.87109e-10, 1.45669e-10, 7.26762e-11, 3.5645e-11, 1.71822e-11, 8.13836e-12, 3.78702e-12, 1.73099e-12, 7.77111e-13, 3.42635e-13, 1.48371e-13, 6.31127e-14, 2.63858e-14},
{1.03722e-05, 3.5774e-05, 0.000108023, 0.000236306, 0.000402558, 0.00061835, 0.000907133, 0.00128535, 0.00176927, 0.00240364, 0.00327355, 0.00446425, 0.0060459, 0.00807277, 0.0105869, 0.0136201, 0.0171703, 0.0211603, 0.0254028, 0.0295994, 0.0333871, 0.0364323, 0.0385279, 0.0396497, 0.0399388, 0.0396305, 0.0389791, 0.0382021, 0.0374468, 0.0367806, 0.0362023, 0.0356656, 0.035105, 0.0344535, 0.0336522, 0.0326549, 0.0314291, 0.0299566, 0.0282325, 0.026266, 0.0240826, 0.0217259, 0.0192569, 0.0167496, 0.0142844, 0.0119384, 0.00977751, 0.00784987, 0.00618288, 0.00478336, 0.00364047, 0.00273061, 0.0020226, 0.0014825, 0.00107729, 0.000777338, 0.00055758, 0.000397781, 0.000282214, 0.000198998, 0.000139324, 9.67397e-05, 6.65386e-05, 4.52879e-05, 3.04777e-05, 2.02697e-05, 1.33192e-05, 8.64726e-06, 5.54823e-06, 3.51937e-06, 2.20801e-06, 1.37071e-06, 8.4228e-07, 5.1242e-07, 3.0866e-07, 1.84063e-07, 1.08632e-07, 6.34254e-08, 3.66136e-08, 2.08845e-08, 1.17631e-08, 6.53802e-09, 3.58358e-09, 1.93585e-09, 1.03008e-09, 5.39635e-10, 2.78205e-10, 1.4109e-10, 7.03636e-11, 3.4498e-11, 1.66236e-11, 7.87129e-12, 3.66168e-12, 1.67325e-12, 7.51004e-13, 3.3105e-13, 1.43327e-13, 6.09571e-14, 2.5482e-14},
{1.05672e-05, 3.64183e-05, 0.000109811, 0.000240295, 0.000409334, 0.000628828, 0.000922205, 0.00130624, 0.00179801, 0.00244271, 0.00332604, 0.00453405, 0.00613735, 0.00819022, 0.0107351, 0.0138042, 0.0173958, 0.0214321, 0.0257239, 0.0299688, 0.0337981, 0.0368718, 0.0389781, 0.0400907, 0.0403518, 0.0400003, 0.0392949, 0.0384582, 0.0376424, 0.0369189, 0.0362886, 0.035706, 0.0351048, 0.0344164, 0.0335802, 0.0325486, 0.0312883, 0.029781, 0.0280219, 0.0260215, 0.0238065, 0.0214219, 0.0189302, 0.0164071, 0.0139336, 0.0115878, 0.00943531, 0.00752359, 0.00587887, 0.00450637, 0.00339354, 0.00251507, 0.00183825, 0.00132791, 0.000950142, 0.00067472, 0.000476286, 0.000334554, 0.000233931, 0.00016279, 0.000112657, 7.74454e-05, 5.28217e-05, 3.57021e-05, 2.38895e-05, 1.58137e-05, 1.03511e-05, 6.69888e-06, 4.28659e-06, 2.71286e-06, 1.69864e-06, 1.05267e-06, 6.45853e-07, 3.92385e-07, 2.36073e-07, 1.40631e-07, 8.29244e-08, 4.83796e-08, 2.79111e-08, 1.5913e-08, 8.9597e-09, 4.97862e-09, 2.72843e-09, 1.47379e-09, 7.84212e-10, 4.1085e-10, 2.11831e-10, 1.07443e-10, 5.35915e-11, 2.62794e-11, 1.26656e-11, 5.99835e-12, 2.79095e-12, 1.27562e-12, 5.72661e-13, 2.52497e-13, 1.09352e-13, 4.65303e-14, 1.94678e-14}};

/*
//Overall PileUp :  Cert_314472-325175_13TeV_17SeptEarlyReReco2018ABC_PromptEraD_Collisions18_JSON.txt

*/



static const int nsrc = 27;   // Change form 26 as for 2015 data .  See JEC for 2017 94X
const char* srcnames[nsrc] =
  {"AbsoluteStat", "AbsoluteScale", "AbsoluteMPFBias", "Fragmentation", "SinglePionECAL", "SinglePionHCAL", "FlavorQCD", "TimePtEta", "RelativeJEREC1", "RelativeJEREC2", "RelativeJERHF","RelativePtBB", "RelativePtEC1", "RelativePtEC2","RelativePtHF","RelativeBal", "RelativeSample", "RelativeFSR", "RelativeStatFSR", "RelativeStatEC", "RelativeStatHF", "PileUpDataMC", "PileUpPtRef", "PileUpPtBB", "PileUpPtEC1", "PileUpPtEC2", "PileUpPtHF"};


double intlumi[nHLTmx]={1., 1, 1, 1, 1, 1,1,1};
double lumiwt[nHLTmx]={1., 1, 1, 1, 1, 1,1,1};
//unsigned int l1trg[4], hlttr[8], tetrg[2];
unsigned int mypow_2[32];

//std::ofstream myfile;
//  myfile.open("txt.log");


//const bool m_trigeff = true;
const int njetptmn=nHLTmx; // 8;
const int njetptbin=120;

#ifdef DIJETAVE
const char* jethlt_name[nHLTmx]={"HLT_DiPFJetAve60_v","HLT_DiPFJetAve80_v", "HLT_DiPFJetAve140_v", "HLT_DiPFJetAve200_v", "HLT_DiPFJetAve260_v", "HLT_DiPFJetAve320_v", "HLT_DiPFJetAve400_v", "HLT_DiPFJetAve500_v"};

//double leadingPtThreshold[njetptmn+1] ={79, 105, 165, 234, 300, 366, 450, 557, 3000.0}; //Fit Value dijet trigger
double leadingPtThreshold[njetptmn+1] ={83, 109, 172, 241, 309, 377, 462, 570, 3000.0}; //Fit Value dijet trigger

//double compres[njetptmn] = {1630, 5320, 62.1, 38.9, 27.0, 4.33, 1.23, 1.0};
//double compres[njetptmn] = {1630, 5320, 62.1, 38.9, 27.0, 4.33, 1.23, 1.0};

// double leadingPtThreshold[njetptmn+1] ={73, 93, 165, 225, 330, 400, 500, 600, 2000.0}; //Fit Value dijet trigger

const char* jethlt_lowest={"HLT_DiPFJetAve40_v"};

//#else

#endif

#ifdef DIJETAVE
double jethlt_thr[nHLTmx]={60,80,140,200,260,320,400,500};
//#else

#endif
double prescl[nHLTmx];

#ifdef TRACKSYS
const int ntype=3;
#else
const int ntype=2;
#endif

const int njetetamn=1; // GMA 4;
#ifdef  LHAPDF
       const int nnnmx=101;
        double pdfwt[nnnmx];
  TH1F* h_genevtvarpdf[ntype][njetptmn][njetetamn][nvar][nnnmx];
#endif

#ifdef  JETENERGY
        //const int nsrc = 26;
        const int njecmx=2*nsrc+1;
  TH1F* h_recoevtvarjec[ntype][njetptmn][njetetamn][nvar][njecmx];
#elif defined(JETRESO)
        const int njecmx = 3;
  TH1F* h_recoevtvarres[ntype][njetptmn][njetetamn][nvar][njecmx];
#else
  const int njecmx=1;
#endif


//#ifdef  JETRESO
//  const int nGenReso = 3;
//  TH1F* h_genevtvarres[ntype][njetptmn][njetetamn][nvar][nGenReso];
//#else
  const int nGenReso=1;
  //const int nGenReso=njecmx;
//#endif

//int trgbit[nHLTmx]={10,11,12,13,14,16};
//double trgpas[nHLTmx+1]={0,0,0,0,0,0,0,0,0};

//const int njetetamn=3;
double etarange[njetetamn] ={2.4}; //{3.0, 2.4, 1.8, 1.3};
double resetarange[njetetamn+4] ={0, 0.5, 1.0, 1.5}; //, 2.0, 2.5, 3.0, 3.5};
double par0[njetetamn+4]={1.02, 1.02, 1.022, 1.017, 0.98}; //, 0.9327};
double par1[njetetamn+4]={7.3e-6, -7.3e-6, -5.66e-6, -9.9e-6, 1.41e-4}; //, 4.6e-4};
double par2[njetetamn+4]={-8.2e-9, -8.2e-9, -3.58e-9, -4.18e-9, -6.104e-8}; //, -4.041e-7};
double particlept[4]={0.0, 0.25, 0.50, 1.00};

//const int ntype=4;
//const char* typname[ntype]={"Jets", "All particle", "All particle: P_{T}>0.25", "All particle: P_{T}>0.50", "All particle: P_{T}>1"};

#ifdef TRACKSYS
const char* typname[ntype]={"Jets", "Charged Particles"};
#else
const char* typname[ntype]={"Jets", "Charged Particles"};
#endif
static const int njetmx =30;

int getbinid(double val, int nbmx, double* array) {
  if (val<array[0]) return -2;
  for (int ix=0; ix<=nbmx; ix++) {
    if (val < array[ix]) return ix-1;
  }
  return -3;
}

double Phi_0_2pi(double x) {
  while (x >= 2*M_PI) x -= 2*M_PI;
  while (x <     0.)  x += 2*M_PI;
  return x;
}

double Phi_mpi_pi(double x) {
  while (x >= M_PI) x -= 2*M_PI;
  while (x < -M_PI) x += 2*M_PI;
  return x;
}



double dPhi(double phi1,double phi2){
  phi1=Phi_0_2pi(phi1);
  phi2=Phi_0_2pi(phi2);
  return Phi_mpi_pi(phi1-phi2);
}

 int sbitx(unsigned ival, int ibit) {
      unsigned den = mypow_2[ibit]; // unsigned(pow(2., double(ibit)));
      int isel = unsigned(ival/den)%2;
 //  int isel = unsigned(ival/den);
       //cout <<"iv "<< ival<<" "<<ibit<<" "<<den<<" "<<ival/den<<" "<<unsigned(ival/den)<<" "<<isel<<endl;

      return isel;
    }

double respfun(double a, double b, double c, double x){
  double func=a+b*x+c*x*x;
  return func;
}


struct triggervar{
  HepLorentzVector trg4v;
  bool		  both;
  bool            level1;
  bool            highl;
  int             ihlt;
  int             prescl;
};

//
// class declaration
//

class QCDEventShape : public edm::EDAnalyzer {
   public:
      explicit QCDEventShape(const edm::ParameterSet&);
      ~QCDEventShape();

      static void fillDescriptions(edm::ConfigurationDescriptions& descriptions);


   private:
      virtual void beginJob() override;
      virtual void analyze(const edm::Event&, const edm::EventSetup&) override;
      virtual void endJob() override;

      virtual void beginRun(edm::Run const&, edm::EventSetup const&) override;
      //virtual void endRun(edm::Run const&, edm::EventSetup const&) override;
      //virtual void beginLuminosityBlock(edm::LuminosityBlock const&, edm::EventSetup const&) override;
      //virtual void endLuminosityBlock(edm::LuminosityBlock const&, edm::EventSetup const&) override;
 // int sbitx(unsigned ival, int ibit);

  bool isHistFill;
  bool isTrigger;
  bool isRECO[ntype][njetetamn];
  bool isMC;
  //  bool isParticle; //Do we want particle level informations, other than jets ?
  //  bool isGenParticle; //Do we want Simulated particle level informations, other than jets ?
  bool isReconstruct; // otherwise Only generator level informations  
  //  bool isPartQCD; //For tracker variables, recosntruct QCD EVT variables
  bool isJetQCD;  //For Jet variables, recosntruct QCD EVT variables
  bool isGenJET; // Genjet information or note (for herwig/alpgen, donot store this ?)
  //  double trackPtThreshold; //Threshold of track Pt to store it in root file, -ve implies don't store

  //  double etarange; //Eta range of all jets
  double ptthreshold; //Pt threshold of JEC jets
  double leadingPtthreshold; //Pt threshold of JEC leading jet
  bool   isOtherAlgo; // store Kt4 and ak7 variables or not
  double weight=1; //weight for histogramme fit
  double weight2=1;

  std::string m_resolutions_file;
  std::string scalefile;

  std::string theHLTTag;
//  unsigned int mypow_2[32];
  int nevt;

  std::string theRootFileName;
  //TFile* //theFile;
 // TTree* //T1;

//  ifstream myfile ("example.txt");
//    std::ofstream myfile;
//    myfile.open("txt.log");


  //TH1F* h_recoevtvar[10][ntype][njetptmn][njetetamn][nvar];
  TH1F* h_recoevtvar[ntype][njetptmn][njetetamn][nvar];

  //TH1F* h_genevtvar[10][ntype][njetptmn][njetetamn][nvar];
  TH1F* h_genevtvar[ntype][njetptmn][njetetamn][nvar];
  TH1F* h_genevtvar2[ntype][njetptmn][njetetamn][nvar];
  

  //TH2F* h_2devtvar[10][ntype][njetptmn][njetetamn][nvar];
  TH2F* h_2devtvar[ntype][njetptmn][njetetamn][nvar];
  TH2F* h_2ht;

  TH1F* vec_anglex[nhist];

  //static const int njetmx =30;
  int npfjets;
  int pfjetmul[njetmx];
  float pfjetpx[njetmx], pfjetpy[njetmx], pfjetpz[njetmx], pfjeten[njetmx],  pfjetenuc[njetmx], neuemf[njetmx], neuhad[njetmx];
  float pfjetenscl[njetmx], pfjetensmr[njetmx];

  float jetpt, jeteta, jetphi; 
  int nallpf, ncharged;
  float thphi[nhist], thrust[nhist], anglex[nhist];
  float jtthan;
  int irunhlt, l1pres[nHLTmx],  hltpres[nHLTmx], compres[nHLTmx]; 
  static const int nprimx=150;
  int nprim, ntkpm[nprimx];
  //  float  primdx[nprimx], primdy[nprimx], primdz[nprimx], 
  float primpr[nprimx];
  int irun, ilumi, ibrnc;
  unsigned int ievt;
  float inslumi;
  int nsicls, ntottrk;
//#ifdef FLAT 
 // bool isFlat=1;
//#else 
    bool isFlat=0;
//#endif

    float defweight=1.0, weighttrg=1., qlow=-10., qhigh=100000.;
  //=============****=========================


  //=============****=========================
  //TH1F* recojt_hist;
//  TH1F* recojt_pt[njetetamn][nHLTmx];
  TH1F* recojt_pt[njetetamn];
  TH1F* recojt_eta;
  TH1F* recojt_phi;

  TH1F* recojtallave_pt[njetetamn];
  TH1F* recojtallavewt1_pt[njetetamn];

  TH1F* recojtave_pt[njetetamn][nHLTmx];
  TH1F* recojtavewt1_pt[njetetamn][nHLTmx];
  TH1F* recojt1_pt[njetetamn];
  TH1F* recojt1_eta;
  TH1F* recojt1_phi;

  TH1F* recojt2_pt[njetetamn];
  TH1F* recojt2_eta;
  TH1F* recojt2_phi;

  TH1F* recojt3_pt[njetetamn];
  TH1F* recojt3_eta;
  TH1F* recojt3_phi;

  TH1F* recoht2_pt[njetetamn];




  TH1F* hjetdpt[njetetamn];
  TH1F* hjetdphi[njetetamn];
  TH1F* hjetptbypl[njetetamn];
  TH1F* hjetpt2bypt1[njetetamn];
  TH1F* hjetpt3bypt2[njetetamn];
  // TH1F* recochg_hist;
  TH1F* recochg_pt;
  TH1F* recochg_eta;
  TH1F* recochg_phi;

  TH1F* recochg1_pt;
  TH1F* recochg1_eta;
  TH1F* recochg1_phi;

  TH1F* recochg2_pt;
  TH1F* recochg2_eta;
  TH1F* recochg2_phi;

  TH1F* recochg3_pt;
  TH1F* recochg3_eta;
  TH1F* recochg3_phi;

  //===============****==============================
  //  TH1F* genjt_hist;
  TH1F* genjt_pt[njetetamn];
  TH1F* genjt_eta;
  TH1F* genjt_phi;
  TH1F* genjtallave_pt[njetetamn];


  TH1F* genjt1_pt[njetetamn];
  TH1F* genjt1_eta;
  TH1F* genjt1_phi;

   TH1F* genjt2_pt[njetetamn];
  TH1F* genjt2_eta;
  TH1F* genjt2_phi;

  TH1F* genjt3_pt[njetetamn];
  TH1F* genjt3_eta;
  TH1F* genjt3_phi;

  TH1F* genjetdpt[njetetamn];
  TH1F* genjetdphi[njetetamn];
  TH1F* genjetptbypl[njetetamn];
  TH1F* genjetpt2bypt1[njetetamn];
  TH1F* genjetpt3bypt2[njetetamn];

  // TH1F* genchg_hist;
  TH1F* genchg_pt;
  TH1F* genchg_eta;
  TH1F* genchg_phi;

  TH1F* genchg1_pt;
  TH1F* genchg1_eta;
  TH1F* genchg1_phi;

  TH1F* genchg2_pt;
  TH1F* genchg2_eta;
  TH1F* genchg2_phi;

  TH1F* genchg3_pt;
  TH1F* genchg3_eta;
  TH1F* genchg3_phi;
/*
  // TH1F* genneu_hist;
  TH1F* genneu_pt;
  TH1F* genneu_eta;
  TH1F* genneu_phi;

  TH1F* genjt_oth_pt[njetetamn];
  TH1F* genjt_oth_eta;
  TH1F* genjt_oth_phi;

  //  TH1F* genchg_oth_hist;
  TH1F* genchg_oth_pt;
  TH1F* genchg_oth_eta;
  TH1F* genchg_oth_phi;

  //  TH1F* genneu_oth_hist;
  TH1F* genneu_oth_pt;
  TH1F* genneu_oth_eta;
  TH1F* genneu_oth_phi;
*/
  //Response hist
  TH2F* resp_jet[njetetamn+2];
  TH1F* resp_jet1[njetetamn+2];

  TH1F* prim_hist[nHLTmx+1];
  TH1F* prim_sel[nHLTmx+1];

  TH1F* prim_hist_rewt[nHLTmx+1];
  TH1F* prim_sel_rewt[nHLTmx+1];

  TH2F* prim_correl;

  TH1F* prim_alltrk[2];
  TH1F* prim_seltrk[2];
  TH1F* prim_goodtrk[2];
  TH1F* prim_dx[2];
  TH1F* prim_dy[2];
  TH2F* prim_dxy[2];
  TH1F* prim_dz[2];  
  TH1F* prim_prob[2];

  TH1F* h_jetpt[nHLTmx][njetetamn];
  TH1F* h_jeteta[nHLTmx];
  TH1F* h_jetphi[nHLTmx][njetetamn];
  TH1F* h_njets[njetetamn];
  TH1F* h_nchg[njetetamn];

  TH1F* gen_njets[njetetamn];




  TH1F* trgjet_angle[nHLTmx][2];
  TH2F* trgjet_2dangle[nHLTmx][2];
  TH1F* trgjet_pt[nHLTmx][2];
  TH1F* trgjet_eta[nHLTmx][2];
  TH1F* trgjet_phi[nHLTmx][2];
  TH1F* prbjet_pt[nHLTmx][2];
  TH1F* prbjet_eta[nHLTmx][2];
  TH1F* prbjet_phi[nHLTmx][2];


  //Dijet trigger efficiency
  TH1F* hlt_dijettag[nHLTmx][njetetamn];
  TH1F* hlt_dijetprob[nHLTmx][njetetamn];

  //Trigger Normal case

  TH1F* counthist;

  // ----------member data ---------------------------
  edm::EDGetTokenT<GenEventInfoProduct> generator1_;
  edm::EDGetTokenT<pat::JetCollection> jetSrcToken_;
  edm::EDGetTokenT<edm::View<pat::PackedGenParticle> > genSrcToken_;
  edm::EDGetTokenT<pat::PackedCandidateCollection> PFSrcToken_;
  edm::EDGetTokenT<edm::TriggerResults> triggerBits_;
  edm::EDGetTokenT<pat::TriggerObjectStandAloneCollection> triggerObjects_;
  edm::EDGetTokenT<pat::PackedTriggerPrescales> triggerPrescales_;
  edm::EDGetTokenT<pat::METCollection> metToken_;
  edm::EDGetTokenT<reco::VertexCollection> vtxToken_;
  edm::EDGetTokenT<reco::BeamSpot> beamSpot_;
  edm::EDGetTokenT<reco::GenJetCollection> genjetToken_;
  edm::EDGetTokenT<std::vector<PileupSummaryInfo> > pileup_;
  edm::EDGetTokenT<reco::PFJetCollection> ak5PFjetToken_;
  edm::EDGetTokenT<reco::GenJetCollection> ak5GenJetToken_;
  const edm::EDGetTokenT<std::vector<double> > pdfCTEQWeightsInputToken_;
  const edm::EDGetTokenT<std::vector<double> > pdfMMTHWeightsInputToken_;
  const edm::EDGetTokenT<std::vector<double> > pdfNNPDFWeightsInputToken_;
  const edm::EDGetTokenT<LHERunInfoProduct> LHERunInfoToken_;
  const edm::EDGetTokenT<LHEEventProduct> lheEventProductToken_;
  edm::EDGetTokenT<double> m_rho_token;

  float qscale;
  float wtfact; //MC : eventinfo->weight(); data : hltpres[ihltfill]*l1pres[ihltfill];
  int procid, npilup1, npilup2; //1:-5 to -1, 2:0 to 3

  int idall;
  float xfrac1, xfrac2, xpdf1, xpdf2;  

  //HLTConfigProvider hltConfig_;
   HLTPrescaleProvider hltPrescaleProvider_;
  int naa, nbb, ncc;

	std::vector<JetCorrectionUncertainty*> vsrc; // (nsrc);
reweight::PoissonMeanShifter PShiftUp_;
reweight::PoissonMeanShifter PShiftDown_;
edm::LumiReWeighting *LumiWeights_;
};

//
// constants, enums and typedefs
//

//
// static data member definitions
//

//
// constructors and destructor
//
QCDEventShape::QCDEventShape(const edm::ParameterSet& iConfig):
  generator1_(consumes<GenEventInfoProduct>(iConfig.getParameter<edm::InputTag>("evtinfo"))),
  jetSrcToken_(consumes<pat::JetCollection>(iConfig.getParameter<edm::InputTag>("jetSrc"))),
  genSrcToken_(consumes<edm::View<pat::PackedGenParticle> >(iConfig.getUntrackedParameter<edm::InputTag>("genSrc"))),
  PFSrcToken_(consumes<pat::PackedCandidateCollection>(iConfig.getParameter<edm::InputTag>("pfSrc"))),
  triggerBits_(consumes<edm::TriggerResults>(iConfig.getParameter<edm::InputTag>("bits"))),
  triggerObjects_(consumes<pat::TriggerObjectStandAloneCollection>(iConfig.getParameter<edm::InputTag>("objects"))),
  triggerPrescales_(consumes<pat::PackedTriggerPrescales>(iConfig.getParameter<edm::InputTag>("prescales"))),
  metToken_(consumes<pat::METCollection>(iConfig.getParameter<edm::InputTag>("metSrc"))),
  vtxToken_(consumes<reco::VertexCollection>(iConfig.getParameter<edm::InputTag>("vertices"))),
  beamSpot_(consumes<reco::BeamSpot>(iConfig.getParameter<edm::InputTag>("bsSrc"))),
  genjetToken_(consumes<reco::GenJetCollection>(iConfig.getParameter<edm::InputTag>("genjetSrc"))),
  pileup_(consumes<std::vector<PileupSummaryInfo> >(iConfig.getParameter<edm::InputTag>("pileupSrc"))),
  ak5PFjetToken_(consumes<reco::PFJetCollection>(iConfig.getParameter<edm::InputTag>("ak5pfJetSrc"))),
  ak5GenJetToken_(consumes<reco::GenJetCollection>(iConfig.getParameter<edm::InputTag>("ak5genJetSrc"))),
  pdfCTEQWeightsInputToken_(consumes<std::vector<double> >(iConfig.getParameter<edm::InputTag>("PDFCTEQWeightsInputTag"))),
  pdfMMTHWeightsInputToken_(consumes<std::vector<double> >(iConfig.getParameter<edm::InputTag>("PDFMMTHWeightsInputTag"))),
  pdfNNPDFWeightsInputToken_(consumes<std::vector<double> >(iConfig.getParameter<edm::InputTag>("PDFNNPDFWeightsInputTag"))),
  LHERunInfoToken_(consumes<LHERunInfoProduct, edm::InRun >(iConfig.getParameter<edm::InputTag>("LHERunInfoProductInputTag"))),
  lheEventProductToken_(consumes<LHEEventProduct>(iConfig.getParameter<edm::InputTag>("LHEEventProductInputTag"))),
  hltPrescaleProvider_(iConfig, consumesCollector(), *this)
{
   //now do what ever initialization is needed
  edm::Service<TFileService> fs;
  m_rho_token = consumes<double>(iConfig.getParameter<edm::InputTag>("rho"));
  //m_resolutions_file = iConfig.getParameter<edm::FileEEInPath>("resolutionsFile").fullPath();
 // scalefile = iConfig.getParameter<edm::FileInPath>("scaleFactorsFile").fullPath();
  isHistFill = iConfig.getUntrackedParameter<bool>("HistFill", true);
  //  isHistFill2 = pset.getUntrackedParameter<bool>("HistFill2", false);                                            
  isTrigger = iConfig.getUntrackedParameter<bool>("Trigger", true);
	//  isRECO = iConfig.getUntrackedParameter<bool>("RECO", false);
  isMC = iConfig.getUntrackedParameter<bool>("MonteCarlo", false);
  isReconstruct = iConfig.getUntrackedParameter<bool>("Reconstruct", true);
  isJetQCD = iConfig.getUntrackedParameter<bool>("JetQCD", false);
  isGenJET = iConfig.getUntrackedParameter<bool>("GenJET", false);
  //  etarange = iConfig.getUntrackedParameter<double>("EtaRange", 5.0);
  ptthreshold = iConfig.getUntrackedParameter<double>("PtThreshold", 10.0);
  //leadingPtthreshold = iConfig.getUntrackedParameter<double>("LeadingPtThreshold", 40.0);
  isOtherAlgo = iConfig.getUntrackedParameter<bool>("OtherAlgo", false);
  weight2 = iConfig.getUntrackedParameter<double>("HistWeight", 1.0);
  weight = weight2;
  theHLTTag = iConfig.getUntrackedParameter<string>("HLTTag", "HLT");
  theRootFileName = iConfig.getUntrackedParameter<string>("RootFileName");
  //theFile = new TFile(theRootFileName.c_str(), "RECREATE");
  //theFile->cd();
  //T1 = new TTree("T1", "QCDEvt");

  //T1->Branch("irun", &irun, "irun/I");  
  //T1->Branch("ilumi", &ilumi, "ilumi/I");  
  //T1->Branch("ievt", &ievt, "ievt/i");
  //T1->Branch("ibrnc", &ibrnc, "ibrnc/I");  
  //T1->Branch("nsicls", &nsicls, "nsicls/I");  //to pf neutral paritcle (excluding HF)
  //T1->Branch("ntottrk", &ntottrk, "ntottrk/I");  //total pfcharged particle (HF)

  //  //T1->Branch("jetpt", &jetpt, "jetpt/F");
  //  //T1->Branch("jeteta", &jeteta, "jeteta/F");
  //  //T1->Branch("jetphi", &jetphi, "jetphi/F");

  //T1->Branch("nallpf", &nallpf, "nallpf/I");
  //T1->Branch("ncharged", &ncharged, "ncharged/I");
  //  //T1->Branch("jtthan",&jtthan,"jtthan/F");
  //  //T1->Branch("thphi",thphi,"thphi[10]/F");

  //T1->Branch("thrust",thrust,"thrust[10]/F");

  //  //T1->Branch("anglex",anglex,"anglex[10]/F");

  //cout << "Testing 1 ==== " <<njecmx<< endl;

  char name[200];
  char title[200];
  // char title2[200];
//  for(int rnum=0; rnum<10; rnum++) {
  for (int ityp=0; ityp<ntype; ityp++) {
    for (int ipt=0; ipt<njetptmn; ipt++) {
      for (int iet=0; iet<njetetamn; iet++) {
	for (int ij=0; ij<nvar; ij++) {
	  if (isItUsed(ij)) { 
	    if (isReconstruct) { 
	      sprintf(name, "reco_typ_%i_pt%i_eta%i_%i", ityp, ipt, iet, ij);
	      sprintf(title, "Reco %s %i %g %s", typname[ityp], int(leadingPtThreshold[ipt]), etarange[iet], vartitle[ij]);
              h_recoevtvar[ityp][ipt][iet][ij] = fs->make<TH1F>(name, title, (ityp==0) ? rnbinsx0[ij][ipt] : rnbinsx1[ij][ipt], (ityp==0) ? rbinrngs0[ij][ipt] : rbinrngs1[ij][ipt]);
            //h_recoevtvar[ityp][ipt][iet][ij] = fs->make<TH1F>(name, title, (ityp==0) ? nbinsx0[ij][ipt] : nbinsx1[ij][ipt], (ityp==0) ? binrngs0[ij][ipt] : binrngs1[ij][ipt] );  
            //h_recoevtvar[ityp][ipt][iet][ij] = fs->make<TH1F>(name, title, (ityp==0) ? nbinsx0[ij] : ((ityp==1 || ityp==3) ? nbinsx1[ij] : nbinsx2[ij]), (ityp==0) ? binrngs0[ij] : ((ityp==1 || ityp==3) ? binrngs1[ij] : binrngs2[ij]));
	      //h_recoevtvar[ityp][ipt][iet][ij] = fs->make<TH1F>(name, title, nbinsx[ij], -endx[ij], -startx[ij]);
	      h_recoevtvar[ityp][ipt][iet][ij]->Sumw2();
	    }
#ifdef  LHAPDF
	    for (int ix=1; ix<nnnmx; ix++) {
	      sprintf(name, "genpdf_typ_%i_pt%i_eta%i_%i_%i", ityp, ipt, iet, ij, ix);
	      sprintf(title, "Genpdf %s %i %g %s %i", typname[ityp], int(leadingPtThreshold[ipt]), etarange[iet], vartitle[ij], ix);
	      h_genevtvarpdf[ityp][ipt][iet][ij][ix] = fs->make<TH1F>(name, title,  (ityp==0) ? nbinsx0[ij][ipt] : nbinsx1[ij][ipt] , (ityp==0) ? binrngs0[ij][ipt] : binrngs1[ij][ipt]);
              // h_genevtvarpdf[ityp][ipt][iet][ij][ix] = fs->make<TH1F>(name, title,  (ityp==0) ? nbinsx0[ij] : ((ityp==1 || ityp==3) ? nbinsx1[ij] : nbinsx2[ij]), (ityp==0) ? binrngs0[ij] : ((ityp==1 || ityp==3) ? binrngs1[ij] : binrngs2[ij]));
	      h_genevtvarpdf[ityp][ipt][iet][ij][ix]->Sumw2();
	    }
#endif
	    
#ifdef  JETENERGY
	    for (int ix=1; ix<njecmx; ix++) {
	      sprintf(name, "recojec_typ_%i_pt%i_eta%i_%i_%i", ityp, ipt, iet, ij, ix);
	      sprintf(title, "Recojec %s %i %g %s %i", typname[ityp], int(leadingPtThreshold[ipt]), etarange[iet], vartitle[ij], ix);
	      h_recoevtvarjec[ityp][ipt][iet][ij][ix] = fs->make<TH1F>(name, title,  (ityp==0) ? nbinsx0[ij][ipt] : nbinsx1[ij][ipt] , (ityp==0) ? binrngs0[ij][ipt] : binrngs1[ij][ipt]);
             // h_recoevtvarjec[ityp][ipt][iet][ij][ix] = fs->make<TH1F>(name, title,  (ityp==0) ? nbinsx0[ij] : ((ityp==1 || ityp==3) ? nbinsx1[ij] : nbinsx2[ij]), (ityp==0) ? binrngs0[ij] : ((ityp==1 || ityp==3) ? binrngs1[ij] : binrngs2[ij]));
	      h_recoevtvarjec[ityp][ipt][iet][ij][ix]->Sumw2();
	    }
#elif defined(JETRESO)
	    for (int ix=1; ix<njecmx; ix++ ) {
	      sprintf(name, "recoreso_typ_%i_pt%i_eta%i_%i_%i", ityp, ipt, iet, ij, ix);
	      sprintf(title, "Recoreso %s %i %g %s %i", typname[ityp], int(leadingPtThreshold[ipt]), etarange[iet], vartitle[ij], ix);
              h_recoevtvarres[ityp][ipt][iet][ij][ix] = fs->make<TH1F>(name, title, (ityp==0) ? nbinsx0[ij][ipt] : nbinsx1[ij][ipt] , (ityp==0) ? binrngs0[ij][ipt] : binrngs1[ij][ipt]);
// h_recoevtvarres[ityp][ipt][iet][ij][ix] = fs->make<TH1F>(name, title, (ityp==0) ? nbinsx0[ij] : ((ityp==1 || ityp==3) ? nbinsx1[ij] : nbinsx2[ij]), (ityp==0) ? binrngs0[ij] : ((ityp==1 || ityp==3) ? binrngs1[ij] : binrngs2[ij]));
	      h_recoevtvarres[ityp][ipt][iet][ij][ix]->Sumw2();
	    }
#endif
	    
	    sprintf(name, "gen_typ_%i_pt%i_eta%i_%i", ityp, ipt, iet, ij);
	    sprintf(title, "Gen %s %i %g %s", typname[ityp], int(leadingPtThreshold[ipt]), etarange[iet], vartitle[ij]);
            //h_genevtvar[ityp][ipt][iet][ij] = fs->make<TH1F>(name, title, (ityp==0) ? nbinsx0[ij][ipt] : nbinsx1[ij][ipt], (ityp==0) ? binrngs0[ij][ipt] : binrngs1[ij][ipt] );
//	    h_genevtvar[ityp][ipt][iet][ij] = fs->make<TH1F>(name, title, (ityp==0) ? nbinsx0[ij] : ((ityp==1 || ityp==3) ? nbinsx1[ij] : nbinsx2[ij]), (ityp==0) ? binrngs0[ij] : ((ityp==1 || ityp==3) ? binrngs1[ij] : binrngs2[ij]));
         // h_genevtvar[ityp][ipt][iet][ij] = fs->make<TH1F>(name, title, nbinsxgen[ij], -endx[ij], -startx[ij]);
            h_genevtvar[ityp][ipt][iet][ij] = fs->make<TH1F>(name, title, nbinsx[ij]/2, -endx[ij], -startx[ij]);
	    h_genevtvar[ityp][ipt][iet][ij]->Sumw2();
	    
	    sprintf(name, "gen2_typ_%i_pt%i_eta%i_%i", ityp, ipt, iet, ij);
	    sprintf(title, "Gen2 %s %i %g %s", typname[ityp], int(leadingPtThreshold[ipt]), etarange[iet], vartitle[ij]);
            h_genevtvar2[ityp][ipt][iet][ij] = fs->make<TH1F>(name, title, (ityp==0) ? nbinsx0[ij][ipt] : nbinsx1[ij][ipt] , (ityp==0) ? binrngs0[ij][ipt] : binrngs1[ij][ipt]);	   
         // h_genevtvar2[ityp][ipt][iet][ij] = fs->make<TH1F>(name, title, (ityp==0) ? nbinsx0[ij] : ((ityp==1 || ityp==3) ? nbinsx1[ij] : nbinsx2[ij]), (ityp==0) ? binrngs0[ij] : ((ityp==1 || ityp==3) ? binrngs1[ij] : binrngs2[ij]));
	    h_genevtvar2[ityp][ipt][iet][ij]->Sumw2();

	    if (isReconstruct) { 
	      sprintf(name, "corr_typ_%i_pt%i_eta%i_%i", ityp , ipt, iet, ij);
	      sprintf(title, "Gen_Reco %s %i %g %s", typname[ityp], int(leadingPtThreshold[ipt]), etarange[iet], vartitle[ij]);
           h_2devtvar[ityp][ipt][iet][ij] = fs->make<TH2F>(name, title, (ityp==0) ? rnbinsx0[ij][ipt] : rnbinsx1[ij][ipt], (ityp==0) ? rbinrngs0[ij][ipt] : rbinrngs1[ij][ipt], (ityp==0) ? nbinsx0[ij][ipt] : nbinsx1[ij][ipt], (ityp==0) ? binrngs0[ij][ipt] : binrngs1[ij][ipt]);   
         // h_2devtvar[ityp][ipt][iet][ij] = fs->make<TH2F>(name, title, (ityp==0) ? nbinsx0[ij][ipt] : nbinsx1[ij][ipt], (ityp==0) ? binrngs0[ij][ipt] : binrngs1[ij][ipt], (ityp==0) ? nbinsx0[ij][ipt] : nbinsx1[ij][ipt], (ityp==0) ? binrngs0[ij][ipt] : binrngs1[ij][ipt]);
        //  h_2devtvar[ityp][ipt][iet][ij] = fs->make<TH2F>(name, title, (ityp==0) ? nbinsx0[ij] : ((ityp==1 || ityp==3) ? nbinsx1[ij] : nbinsx2[ij]), (ityp==0) ? binrngs0[ij] : ((ityp==1 || ityp==3) ? binrngs1[ij] : binrngs2[ij]), (ityp==0) ? nbinsx0[ij] : ((ityp==1 || ityp==3) ? nbinsx1[ij] : nbinsx2[ij]), (ityp==0) ? binrngs0[ij] : ((ityp==1 || ityp==3) ? binrngs1[ij] : binrngs2[ij]));
      //    h_2devtvar[ityp][ipt][iet][ij] = fs->make<TH2F>(name, title, nbinsxgen[ij], -endx[ij], -startx[ij], nbinsx[ij], -endx[ij], -startx[ij]);
	 //   h_2devtvar[ityp][ipt][iet][ij] = fs->make<TH2F>(name, title, nbinsx[ij], -endx[ij], -startx[ij], nbinsx[ij]/2, -endx[ij], -startx[ij]);
	    h_2devtvar[ityp][ipt][iet][ij]->Sumw2();
	    }
	  }
	  //cout <<"ijx "<< ityp<<" "<< ipt<<" "<< iet<<" "<<ij<<endl;
	  
	}
      }
    }
  }
 //}
 sprintf(name, "corr_jet");
 sprintf(title, "Gen_Reco_HT2");
 h_2ht=fs->make<TH2F>(name, title, 8, leadingPtThreshold, 8, leadingPtThreshold);


  //==============****================================  
#ifndef GENPART                     
  //  recojt_hist = fs->make<TH1F>("recojt_hist","# of recojets",20,-0.5, 19.5);
  // recojt_hist->Sumw2();
  //recojt_pt = fs->make<TH1F>("recojt_pt","Et_{recojets}",100,20., 2020.);
  //recojt_pt->Sumw2();
  recojt_eta = fs->make<TH1F>("recojt_eta","#eta_{recojets}",100,-2.5, 2.5);
  recojt_eta->Sumw2();
  recojt_phi = fs->make<TH1F>("recojt_phi","#phi_{recojets}",100,-M_PI, M_PI);
  recojt_phi->Sumw2();

  //recojt1_pt = fs->make<TH1F>("recojet1_pt","Et_{recojets}",100,20., 2020.);
  //recojt1_pt->Sumw2();
  recojt1_eta = fs->make<TH1F>("recojet1_eta","#eta_{recojets}",100,-2.5, 2.5);
  recojt1_eta->Sumw2();
  recojt1_phi = fs->make<TH1F>("recojet1_phi","#phi_{recojets}",100,-M_PI, M_PI);
  recojt1_phi->Sumw2();

  //recojt2_pt = fs->make<TH1F>("recojet2_pt","Et_{recojets}",100,20., 2020.);
  //recojt2_pt->Sumw2();
  recojt2_eta = fs->make<TH1F>("recojet2_eta","#eta_{recojets}",100,-2.5, 2.5);
  recojt2_eta->Sumw2();
  recojt2_phi = fs->make<TH1F>("recojet2_phi","#phi_{recojets}",100,-M_PI, M_PI);
  recojt2_phi->Sumw2();

  // recojt3_pt = fs->make<TH1F>("recojet2_pt","Et_{recojets}",100,20., 2020.);
  //recojt3_pt->Sumw2();
  recojt3_eta = fs->make<TH1F>("recojet2_eta","#eta_{recojets}",100,-2.5, 2.5);
  recojt3_eta->Sumw2();
  recojt3_phi = fs->make<TH1F>("recojet2_phi","#phi_{recojets}",100,-M_PI, M_PI);
  recojt3_phi->Sumw2();


  for(int jk=0; jk<njetetamn; jk++){
    sprintf(name, "recojetallave_pt_%i",jk);
    sprintf(title, "Et_{recojetsallave}_%g", etarange[jk]);
    recojtallave_pt[jk] = fs->make<TH1F>(name,title,400, 20., 2020.);
    recojtallave_pt[jk]->Sumw2();

    sprintf(name, "recojetallavewt1_pt_%i",jk);
    sprintf(title, "Et_{recojetsallavewt1}_%g", etarange[jk]);
    recojtallavewt1_pt[jk] = fs->make<TH1F>(name,title,400, 20., 2020.);
    recojtallavewt1_pt[jk]->Sumw2();

    sprintf(name, "recojt_pt_%i",jk);
    sprintf(title, "Et_{recojets}_%g", etarange[jk]);
    recojt_pt[jk] = fs->make<TH1F>(name,title, 400, 20., 2020.);
    recojt_pt[jk]->Sumw2();

    sprintf(name, "recojet1_pt_%i",jk);
    sprintf(title, "Et_{recojets1}_%g", etarange[jk]);
    recojt1_pt[jk] = fs->make<TH1F>(name,title, 400, 20., 2020.);
    recojt1_pt[jk]->Sumw2();


    sprintf(name, "recojet2_pt_%i",jk);
    sprintf(title, "Et_{recojets2}_%g", etarange[jk]);
    recojt2_pt[jk] = fs->make<TH1F>(name,title, 400, 20., 2020.);
    recojt2_pt[jk]->Sumw2();


    sprintf(name, "recojet3_pt_%i",jk);
    sprintf(title, "Et_{recojets3}_%g", etarange[jk]);
    recojt3_pt[jk] = fs->make<TH1F>(name,title, 400, 20., 2020.);
    recojt3_pt[jk]->Sumw2();


    for (int kl=0; kl<nHLTmx; kl++) { 
      //  sprintf(name, "recojt_pt_%i_%i",jk, kl);
      //  sprintf(title, "Et_{recojets}_%g_%i", etarange[jk], kl);
      //  recojt_pt[jk][kl] = fs->make<TH1F>(name,title, 400, 20., 2020.);
      //  recojt_pt[jk][kl]->Sumw2();

      sprintf(name, "recojetave_pt_%i_%i",jk, kl);
      sprintf(title, "Et_{recojetsave}_%g_%i", etarange[jk], kl);
      recojtave_pt[jk][kl] = fs->make<TH1F>(name,title, 400, 20., 2020.);
      recojtave_pt[jk][kl]->Sumw2();

      sprintf(name, "recojetavewt1_pt_%i_%i",jk, kl);
      sprintf(title, "Et_{recojetsavewt1}_%g_%i", etarange[jk], kl);
      recojtavewt1_pt[jk][kl] = fs->make<TH1F>(name,title, 400, 20., 2020.);
      recojtavewt1_pt[jk][kl]->Sumw2();
    }

    sprintf(name, "recojetHT2_%i",jk);
    sprintf(title, "recojetsHT2_%g", etarange[jk]);

    recoht2_pt[jk] = fs->make<TH1F>(name, title, 400,20., 1500.);
    recoht2_pt[jk]->Sumw2();


    sprintf(name, "hjetdpt_%i",jk);
    sprintf(title, "dpt_{recojets12}_%g", etarange[jk]);

    hjetdpt[jk] = fs->make<TH1F>(name, title, 100,20., 500.);
    hjetdpt[jk]->Sumw2();

    sprintf(name, "hjetpt2bypt1_%i",jk);
    sprintf(title, "hjetpt2bypt1 reco jet_%g", etarange[jk]);


    hjetpt2bypt1[jk] = fs->make<TH1F>(name, title, 60, 0., 1.0);
    hjetpt2bypt1[jk]->Sumw2();

    sprintf(name, "hjetpt3bypt2_%i",jk);
    sprintf(title, "hjetpt3bypt2 reco jet_%g", etarange[jk]);
    hjetpt3bypt2[jk] = fs->make<TH1F>(name, title, 60, 0., 1.0);
    hjetpt3bypt2[jk]->Sumw2();


    sprintf(name, "hjetdphi_%i",jk);
    sprintf(title, "#phi_{recojets}_%g", etarange[jk]);
    hjetdphi[jk] = fs->make<TH1F>(name,title,100,-M_PI, M_PI);
    hjetdphi[jk]->Sumw2();
    sprintf(name, "hjetptbypl_%i",jk);
    sprintf(title, "1st recojet Pt*sin/1st Recojet_%g", etarange[jk]);
    hjetptbypl[jk] = fs->make<TH1F>(name, title, 60, 0., 1.0);
    hjetptbypl[jk]->Sumw2();

    //hjetpt2bypt1 = fs->make<TH1F>("hjetpt2bypt1", "hjetpt2bypt1 reco jet", 60, 0., 1.0);
    //hjetpt2bypt1->Sumw2();
    //hjetpt3bypt2 = fs->make<TH1F>("hjetpt2bypt1", "hjetpt2bypt1 reco jet", 60, 0., 1.0);
    //hjetpt3bypt2->Sumw2();

  }

  recochg_pt = fs->make<TH1F>("recochg_pt","Et_{recocharge_alljet}",100, 1., 101.);
  recochg_pt->Sumw2();
  recochg_eta = fs->make<TH1F>("recochg_eta","#eta_{recocharge_alljet}",100,-3., 3.);
  recochg_eta->Sumw2();
  recochg_phi = fs->make<TH1F>("recochg_phi","#phi_{recocharge_alljet}",100,-M_PI, M_PI);
  recochg_phi->Sumw2();


  recochg1_pt = fs->make<TH1F>("recochg1_pt","Et_{recocharge_jet1}",100, 1., 101.);
  recochg1_pt->Sumw2();
  recochg1_eta = fs->make<TH1F>("recochg1_eta","#eta_{recocharge_jet1}",100,-3., 3.);
  recochg1_eta->Sumw2();
  recochg1_phi = fs->make<TH1F>("recochg1_phi","#phi_{recocharge_jet1}",100,-M_PI, M_PI);
  recochg1_phi->Sumw2();

  recochg2_pt = fs->make<TH1F>("recochg2_pt","Et_{recocharge_jet2}",100, 1., 101.);
  recochg2_pt->Sumw2();
  recochg2_eta = fs->make<TH1F>("recochg2_eta","#eta_{recocharge_jet2}",100,-3., 3.);
  recochg2_eta->Sumw2();
  recochg2_phi = fs->make<TH1F>("recochg2_phi","#phi_{recocharge_jet2}",100,-M_PI, M_PI);
  recochg2_phi->Sumw2();

  recochg3_pt = fs->make<TH1F>("recochg3_pt","Et_{recocharge_jet3}",100, 1., 101.);
  recochg3_pt->Sumw2();
  recochg3_eta = fs->make<TH1F>("recochg3_eta","#eta_{recocharge_jet3}",100,-3., 3.);
  recochg3_eta->Sumw2();
  recochg3_phi = fs->make<TH1F>("recochg3_phi","#phi_{recocharge_jet3}",100,-M_PI, M_PI);
  recochg3_phi->Sumw2();



#endif

 //================*****===================================
  for (int ij=0; ij<nhist; ij++) {
    sprintf(name, "anglex_%i", ij);
    vec_anglex[ij] = fs->make<TH1F>(name, name, 240, 0.7, 1.0);
  }
  // genjt_hist = fs->make<TH1F>("genjt_hist","# of genjets",20,-0.5, 19.5);
  // genjt_hist->Sumw2();
  for(int jk=0; jk<njetetamn; jk++){
    sprintf(name, "genjetallave_pt_%i",jk);
    sprintf(title, "Et_{genjetsallave}_%g", etarange[jk]);
    genjtallave_pt[jk] = fs->make<TH1F>(name,title,400, 20., 2020.);
    genjtallave_pt[jk]->Sumw2();

    sprintf(name, "genjt_pt_%i",jk);
    sprintf(title, "Et_{genjets}_%g", etarange[jk]);
    genjt_pt[jk] = fs->make<TH1F>(name,title, 400, 20., 2020.);
    genjt_pt[jk]->Sumw2();

    sprintf(name, "genjet1_pt_%i",jk);
    sprintf(title, "Et_{genjets1}_%g", etarange[jk]);
    genjt1_pt[jk] = fs->make<TH1F>(name,title, 400, 20., 2020.);
    genjt1_pt[jk]->Sumw2();

    sprintf(name, "genjet2_pt_%i",jk);
    sprintf(title, "Et_{genjets2}_%g", etarange[jk]);
    genjt2_pt[jk] = fs->make<TH1F>(name,title, 400, 20., 2020.);
    genjt2_pt[jk]->Sumw2();

    sprintf(name, "genjet3_pt_%i",jk);
    sprintf(title, "Et_{genjets3}_%g", etarange[jk]);
    genjt3_pt[jk] = fs->make<TH1F>(name,title, 400, 20., 2020.);
    genjt3_pt[jk]->Sumw2();

    /*sprintf(name, "genjt_oth_pt_%i",jk);
    sprintf(title, "#Et_{genjets_oth}_%g", etarange[jk]);

    genjt_oth_pt[jk] = fs->make<TH1F>(name,title,100, 20., 2020.);
    genjt_oth_pt[jk]->Sumw2();
   */
    sprintf(name, "genjetdpt_%i",jk);
    sprintf(title, "dpt_{genjets12}_%g", etarange[jk]);

    genjetdpt[jk] = fs->make<TH1F>(name, title, 100,20., 500.);
    genjetdpt[jk]->Sumw2();

    sprintf(name, "genjetpt2bypt1_%i",jk);
    sprintf(title, "jetpt2bypt1 gen jet_%g", etarange[jk]);

    genjetpt2bypt1[jk] = fs->make<TH1F>(name, title, 60, 0., 1.0);
    genjetpt2bypt1[jk]->Sumw2();

    sprintf(name, "genjetpt3bypt2_%i",jk);
    sprintf(title, "hjetpt3bypt2 gen jet_%g", etarange[jk]);
    genjetpt3bypt2[jk] = fs->make<TH1F>(name, title, 60, 0., 1.0);
    genjetpt3bypt2[jk]->Sumw2();

    sprintf(name, "genjetdphi_%i",jk);
    sprintf(title, "#phi_{genjets}_%g", etarange[jk]);
    genjetdphi[jk] = fs->make<TH1F>(name,title,100,-M_PI, M_PI);
    genjetdphi[jk]->Sumw2();
    sprintf(name, "genjetptbypl_%i",jk);
    sprintf(title, "1st genjet Pt*sin/1st genjet_%g", etarange[jk]);
    genjetptbypl[jk] = fs->make<TH1F>(name, title, 60, 0., 1.0);
    genjetptbypl[jk]->Sumw2();
  }

  for(int jk=0; jk<njetetamn+2; jk++){
    sprintf(name, "response_jet_distribution_%i",jk);
    sprintf(title, "response_2d_ratio_eta_%g_%g", resetarange[jk], resetarange[jk+1]);
    resp_jet[jk] = fs->make<TH2F>(name,title,400, 20., 2020., 50 , 0.0, 5.0);
    resp_jet[jk]->Sumw2();
    sprintf(name, "response_jet_distribution_resolution%i",jk);
    sprintf(title, "response_1d_resulation_eta_%g_%g", resetarange[jk], resetarange[jk+1]);
    resp_jet1[jk] = fs->make<TH1F>(name,title, 100 , 0.0, 1);
    resp_jet1[jk]->Sumw2();
  }

  //genjt_pt = fs->make<TH1F>("genjt_pt","Et_{genjets}",100,20., 2020.);
  // genjt_pt->Sumw2();
  genjt_eta = fs->make<TH1F>("genjt_eta","#eta_{genjets}",100,-2.5, 2.5);
  genjt_eta->Sumw2();
  genjt_phi = fs->make<TH1F>("genjt_phi","#phi_{genjets}",100,-M_PI, M_PI);
  genjt_phi->Sumw2();

  genjt1_eta = fs->make<TH1F>("genjet1_eta","#eta_{genjets}",100,-2.5, 2.5);
  genjt1_eta->Sumw2();
  genjt1_phi = fs->make<TH1F>("genjet1_phi","#phi_{genjets}",100,-M_PI, M_PI);
  genjt1_phi->Sumw2();

  genjt2_eta = fs->make<TH1F>("genjet2_eta","#eta_{genjets}",100,-2.5, 2.5);
  genjt2_eta->Sumw2();
  genjt2_phi = fs->make<TH1F>("genjet2_phi","#phi_{genjets}",100,-M_PI, M_PI);
  genjt2_phi->Sumw2();

  genjt3_eta = fs->make<TH1F>("genjet2_eta","#eta_{genjets}",100,-2.5, 2.5);
  genjt3_eta->Sumw2();
  genjt3_phi = fs->make<TH1F>("genjet2_phi","#phi_{genjets}",100,-M_PI, M_PI);
  genjt3_phi->Sumw2();
  //  genjt_oth_pt = fs->make<TH1F>("genjt_oth_pt","Et_{genjets_oth}",100, 20., 2020.);
  //  genjt_oth_pt->Sumw2();
/*  genjt_oth_eta = fs->make<TH1F>("genjt_oth_eta","#eta_{genjets_oth}",100,-5., 5.);
  genjt_oth_eta->Sumw2();
  genjt_oth_phi = fs->make<TH1F>("genjt_oth_phi","#phi_{genjets_oth}",100,-M_PI, M_PI);
  genjt_oth_phi->Sumw2();
*/
  // genchg_hist = fs->make<TH1F>("genchg_hist","# of genchargeds",120,-0.5, 239.5);
  // genchg_hist->Sumw2();
  genchg_pt = fs->make<TH1F>("genchg_pt","Et_{gencharge_alljet}",100, 1., 101.);
  genchg_pt->Sumw2();
  genchg_eta = fs->make<TH1F>("genchg_eta","#eta_{gencharge_alljet)",100,-3., 3.);
  genchg_eta->Sumw2();
  genchg_phi = fs->make<TH1F>("genchg_phi","#phi_{gencharge_alljet}",100,-M_PI, M_PI);
  genchg_phi->Sumw2();

  genchg1_pt = fs->make<TH1F>("genchg1_pt","Et_{gencharge_jet1}",100, 1., 101.);
  genchg1_pt->Sumw2();
  genchg1_eta = fs->make<TH1F>("genchg1_eta","#eta_{gencharge_jet1}",100,-3., 3.);
  genchg1_eta->Sumw2();
  genchg1_phi = fs->make<TH1F>("genchg1_phi","#phi_{gencharge_jet1}",100,-M_PI, M_PI);
  genchg1_phi->Sumw2(); 

  genchg2_pt = fs->make<TH1F>("genchg2_pt","Et_{gencharge_jet2}",100, 1., 101.);
  genchg2_pt->Sumw2();
  genchg2_eta = fs->make<TH1F>("genchg2_eta","#eta_{gencharge_jet2}",100,-3., 3.);
  genchg2_eta->Sumw2();
  genchg2_phi = fs->make<TH1F>("genchg2_phi","#phi_{gencharge_jet2}",100,-M_PI, M_PI);
  genchg2_phi->Sumw2();

  genchg3_pt = fs->make<TH1F>("genchg3_pt","Et_{gencharge_jet3}",100, 1., 101.);
  genchg3_pt->Sumw2();
  genchg3_eta = fs->make<TH1F>("genchg3_eta","#eta_{gencharge_jet3}",100,-3., 3.);
  genchg3_eta->Sumw2();
  genchg3_phi = fs->make<TH1F>("genchg3_phi","#phi_{gencharge_jet3}",100,-M_PI, M_PI);
  genchg3_phi->Sumw2();

 

  // genchg_oth_hist = fs->make<TH1F>("genchg_oth_hist","# of genchargeds (others)",120,-0.5, 239.5);
  // genchg_oth_hist->Sumw2();
 /* genchg_oth_pt = fs->make<TH1F>("genchg_oth_pt","Et_{genchargeds_oth}",100,1., 101.);
  genchg_oth_pt->Sumw2();
  genchg_oth_eta = fs->make<TH1F>("genchg_oth_eta","#eta_{genchargeds_oth}",100,-5., 5.);
  genchg_oth_eta->Sumw2();
  genchg_oth_phi = fs->make<TH1F>("genchg_oth_phi","#phi_{genchargeds_oth}",100,-M_PI, M_PI);
  genchg_oth_phi->Sumw2();
  // genneu_hist = fs->make<TH1F>("genneu_hist","# of genneutrals",120,-0.5, 239.5);
  // genneu_hist->Sumw2();
  genneu_pt = fs->make<TH1F>("genneu_pt","Et_{genneutrals}",100,1., 101.);
  genneu_pt->Sumw2();
  genneu_eta = fs->make<TH1F>("genneu_eta","#eta_{genneutrals}",100,-3., 3.);
  genneu_eta->Sumw2();
  genneu_phi = fs->make<TH1F>("genneu_phi","#phi_{genneutrals}",100,-M_PI, M_PI);
  genneu_phi->Sumw2();

  // genneu_oth_hist = fs->make<TH1F>("genneu_oth_hist","# of genneutrals (others)",120,-0.5, 239.5);
  // genneu_oth_hist->Sumw2();
  genneu_oth_pt = fs->make<TH1F>("genneu_oth_pt","Et_{genneutrals_oth}",100, 1., 101.);
  genneu_oth_pt->Sumw2();
  genneu_oth_eta = fs->make<TH1F>("genneu_oth_eta","#eta_{genneutrals_oth}",100,-5., 5.);
  genneu_oth_eta->Sumw2();
  genneu_oth_phi = fs->make<TH1F>("genneu_oth_phi","#phi_{genneutrals_oth}",100,-M_PI, M_PI);
  genneu_oth_phi->Sumw2();
*/
  for (int ij=0; ij<nHLTmx; ij++) { 
    sprintf(name, "nprimall_%i", ij);
    sprintf(title, "# of primary vtx (%s)", (ij==0) ? "ALL" : jethlt_name[ij-1]);
    prim_hist[ij] = fs->make<TH1F>(name, title, 60, -0.5, 59.5);
    prim_hist[ij]->Sumw2();

    sprintf(name, "nprimsel_%i", ij);
    sprintf(title, "Selected # of primary vtx (%s)", (ij==0) ? "ALL" : jethlt_name[ij-1]);
    prim_sel[ij] = fs->make<TH1F>(name, title, 60, -0.5, 59.5);
    prim_sel[ij]->Sumw2();

    sprintf(name, "nprimall_rewt_%i", ij);
    sprintf(title, "# of rewighted primary vtx (%s)", (ij==0) ? "ALL" : jethlt_name[ij-1]);
    prim_hist_rewt[ij] = fs->make<TH1F>(name, title, 60, -0.5, 59.5);
    prim_hist_rewt[ij]->Sumw2();

    sprintf(name, "nprimsel_rewt_%i", ij);
    sprintf(title, "Selected # of reweighted primary vtx (%s)", (ij==0) ? "ALL" : jethlt_name[ij-1]);
    prim_sel_rewt[ij] = fs->make<TH1F>(name, title, 60, -0.5, 59.5);
    prim_sel_rewt[ij]->Sumw2();
  }

  prim_correl = fs->make<TH2F>("correl", "Correlation of all and Selected # of primary vtx", 60, -0.5, 59.5, 60, -0.5, 59.5);
  const char* namex[2]={"Selected", "Rejected"};
  for (int ij=0; ij<2; ij++) {
    sprintf(name, "primalltrk_%i", ij);
    sprintf(title, "All tracks in primary vtx (%s)", namex[ij]);
    prim_alltrk[ij] = fs->make<TH1F>(name, title, 240, -0.5, 239.5);

    sprintf(name, "primgoodtrk_%i", ij);
    sprintf(title, "Good tracks in primary vtx (%s)", namex[ij]);
    prim_goodtrk[ij] = fs->make<TH1F>(name, title, 240, -0.5, 239.5);

    sprintf(name, "primseltrk_%i", ij);
    sprintf(title, "Selected tracks in primary vtx (%s)", namex[ij]);
    prim_seltrk[ij] = fs->make<TH1F>(name, title, 240, -0.5, 239.5);

    sprintf(name, "primdx_%i", ij);
    sprintf(title, "#Delta x of prim wrt beam spot (%s)", namex[ij]);
    prim_dx[ij] = fs->make<TH1F>(name, title, 120, -2.4, 2.4);

    sprintf(name, "primdy_%i", ij);
    sprintf(title, "#Delta y of prim wrt beam spot (%s)", namex[ij]);
    prim_dy[ij] = fs->make<TH1F>(name, title, 120, -2.4, 2.4);

    sprintf(name, "primdxy_%i", ij);
    sprintf(title, "#Delta y vs #Delta x of prim (%s)", namex[ij]);
    prim_dxy[ij] = fs->make<TH2F>(name, title, 60, -0.15, 0.15, 60, -0.15, 0.15);

    sprintf(name, "primdz_%i", ij);
    sprintf(title, "#Delta z of prim wrt beam spo (%s)", namex[ij]);
    prim_dz[ij] = fs->make<TH1F>(name, title, 120, -30.0, 30.0); 

    sprintf(name, "primprob_%i", ij);
    sprintf(title, "log10(vertex fit prob) (%s)", namex[ij]);
    prim_prob[ij] = fs->make<TH1F>(name, title, 120, -20.0, 0.0);   
  }

  for(int ij=0; ij<njetetamn; ij++){
    sprintf(name, "njets_%i",ij);
    sprintf(title, "No of Jets_eta range_%gs", etarange[ij]);
    h_njets[ij] = fs->make<TH1F>(name, title, 60, 0, 30);
    h_njets[ij]->Sumw2();
  }

  for(int ij=0; ij<njetetamn; ij++){
    sprintf(name, "ncharges_%i",ij);
    sprintf(title, "No of charge particles_eta range_%gs", etarange[ij]);
    h_nchg[ij] = fs->make<TH1F>(name, title, 800, 0, 400);
    h_nchg[ij]->Sumw2();
  }


  for(int ij=0; ij<njetetamn; ij++){
    sprintf(name, "gennjets_%i",ij);
    sprintf(title, "No of GenJets_eta range_%gs", etarange[ij]);
    gen_njets[ij] = fs->make<TH1F>(name, title, 60, 0, 30);
    gen_njets[ij]->Sumw2();
  }


#ifdef TRIGGER
  const char* trigvar[2]={"L1", "HLT"};
  for(int ij=0; ij<nHLTmx; ij++){
    for(int jk=0; jk<2; jk++){
      sprintf(name, "trgjet_pt_%i_%i", ij, jk);
      sprintf(title, "trgjet_pt_%s_%s", jethlt_name[ij], trigvar[jk]);
      trgjet_pt[ij][jk] = fs->make<TH1F>(name, title, njetptbin, 20,1500);
      trgjet_pt[ij][jk]->Sumw2();

      sprintf(name, "trgjet_eta_%i_%i", ij, jk);
      sprintf(title, "trgjet_eta_%s_%s", jethlt_name[ij], trigvar[jk]);
      trgjet_eta[ij][jk] = fs->make<TH1F>(name, title, njetptbin, -5., 5.);
      trgjet_eta[ij][jk]->Sumw2();

      sprintf(name, "trgjet_phi_%i_%i", ij, jk);
      sprintf(title, "trgjet_phi_%s_%s", jethlt_name[ij], trigvar[jk]);
      trgjet_phi[ij][jk] = fs->make<TH1F>(name, title, 180,-M_PI, M_PI);
      trgjet_phi[ij][jk]->Sumw2();

      sprintf(name, "prbjet_pt_%i_%i", ij, jk);
      sprintf(title, "prbjet_pt_%s_%s", jethlt_name[ij], trigvar[jk]);
      prbjet_pt[ij][jk] = fs->make<TH1F>(name, title, njetptbin, 20,1500);
      prbjet_pt[ij][jk]->Sumw2();

      sprintf(name, "prbjet_eta_%i_%i", ij, jk);
      sprintf(title, "prbjet_eta_%s_%s", jethlt_name[ij], trigvar[jk]);
      prbjet_eta[ij][jk] = fs->make<TH1F>(name, title, 100,-5., 5.);
      prbjet_eta[ij][jk]->Sumw2();

      sprintf(name, "prbjet_phi_%i_%i", ij, jk);
      sprintf(title, "prbjet_phi_%s_%s", jethlt_name[ij], trigvar[jk]);
      prbjet_phi[ij][jk] = fs->make<TH1F>(name, title, 180,-M_PI, M_PI);
      prbjet_phi[ij][jk]->Sumw2();


    }
  } 
#endif
//Trigger special

//=================================

	if (isReconstruct) { 
		for(int ij=0; ij<nHLTmx; ij++){
			for(int jk=0; jk<njetetamn; jk++){
				sprintf(name, "jetpt_%i_%i",jk,ij);
				sprintf(title, "jetpt_%s_%g", jethlt_name[ij], etarange[jk]);
				h_jetpt[ij][jk] = fs->make<TH1F>(name, title, 300, 50, 1550);
				h_jetpt[ij][jk]->Sumw2();
				
				sprintf(name, "jetphi_%i_%i",jk, ij);
				sprintf(title, "jetphi_%s_%g", jethlt_name[ij],etarange[jk]);
				h_jetphi[ij][jk] = fs->make<TH1F>(name, title, 180,-M_PI, M_PI);
				h_jetphi[ij][jk]->Sumw2();
				
			}
		}
	}
#ifdef TRIGGER
  for(int ij=0; ij<nHLTmx; ij++){

    sprintf(name, "jeteta_%i", ij);
    sprintf(title, "jetphi_%s", jethlt_name[ij]);//, jetvar[ij]);
    h_jeteta[ij] = fs->make<TH1F>(name, title, 100, -5, 5);
    h_jeteta[ij]->Sumw2();

    for (int jk=0; jk<2; jk++){ 
      sprintf(name, "angle1d_%s_%i", jethlt_name[ij], jk);
      sprintf(title, "Angle%s_%i", jethlt_name[ij], jk);
      trgjet_angle[ij][jk] = fs->make<TH1F>(name, title, 90 , 0.1, 2.5);

      sprintf(name, "angle2d_%s_%i", jethlt_name[ij], jk);
      sprintf(title, "Angle_2d_hist%s_%i", jethlt_name[ij], jk);
      trgjet_2dangle[ij][jk] = fs->make<TH2F>(name, title, njetptbin, 20, 1500, 30 , 0.1, 2.5);
    }
  }

  for (int ij=0; ij<nHLTmx; ij++) {
    for (int jk=0; jk<njetetamn; jk++) {
      sprintf(name, "hlt_dijettag_%i_%i", ij, jk);
      sprintf(title, "dijet tagged P_T : (%s) |i#eta|<%g", jethlt_name[ij], etarange[jk]);
      hlt_dijettag[ij][jk] = fs->make<TH1F>(name, title, 60, 0.4*leadingPtThreshold[ij], 2.5*leadingPtThreshold[ij]);
      hlt_dijettag[ij][jk]->Sumw2();

      sprintf(name, "hlt_dijetprob_%i_%i", ij, jk);
      sprintf(title, "dijet probed P_T : (%s) |i#eta|<%g", jethlt_name[ij], etarange[jk]);
      hlt_dijetprob[ij][jk] = fs->make<TH1F>(name, title, 60, 0.4*leadingPtThreshold[ij], 2.5*leadingPtThreshold[ij]);
      hlt_dijetprob[ij][jk]->Sumw2();
    }
  }
#endif
  counthist = fs->make<TH1F>("count","No of events",2,0,2); 



  for (int ix=0; ix<32; ix++) { mypow_2[ix] = pow(2,ix);}
  nevt = 0;
  // irun_old=-1;
  //trig_init=0;

  naa= nbb= ncc=0;

}




QCDEventShape::~QCDEventShape()
{

   // do anything here that needs to be done at desctruction time
   // (e.g. close files, deallocate resources etc.)

}


//
// member functions
//

// ------------ method called for each event  ------------
void QCDEventShape::analyze(const edm::Event& iEvent, const edm::EventSetup& iSetup) {
 // t1=clock();
  using namespace edm;
  using namespace std;
  using namespace reco;
  using namespace pat;
  //gRandom->SetSeed(19919925);
  //float rn=gRandom->Uniform();
  //cout << " Random Number ini = " << rn << endl;
  //if (rn >0.90) return;
 // cout << " Random Number = " << rn << endl;
  //cout << "Time = " << t1 << "; " << t2 << endl;
  nevt++;
  int ievt = iEvent.id().event();
  counthist->Fill(1); 
  if (nevt%10000==1)   std::cout<<"QCDEventShape::analyze "<< nevt<<" IRUN= "<<iEvent.id().run()<<" ievt= "<< iEvent.id().event()<<" "<<ievt<<endl;
  //" ilumi" <<
 //iEvent.luminosityBlock() << " ibunch " << iEvent.bunchCrossing() <<std::endl;
 // cout << "NEvent = " <<  nevt << endl;
 // if(iEvent.luminosityBlock()==9881 || iEvent.luminosityBlock()==23185 || iEvent.luminosityBlock()==25334 || iEvent.luminosityBlock()== 26584 ||iEvent.luminosityBlock()== 35674 || iEvent.luminosityBlock()==32764 || iEvent.luminosityBlock()== 35675 || iEvent.luminosityBlock()==53681) return ;
 //if(iEvent.luminosityBlock()==2 || iEvent.luminosityBlock()==7175 || iEvent.luminosityBlock()==41151 || iEvent.luminosityBlock()==7389697 || iEvent.luminosityBlock()==60334 || iEvent.luminosityBlock()==51317 || iEvent.luminosityBlock()==53654 || iEvent.luminosityBlock()==10333 || iEvent.luminosityBlock()==54778 || iEvent.luminosityBlock()==10082 || iEvent.luminosityBlock()==54322 || iEvent.luminosityBlock()==64667 || iEvent.luminosityBlock()==65977 || iEvent.luminosityBlock()==55534 || iEvent.luminosityBlock()==55781 || iEvent.luminosityBlock()==55782 || iEvent.luminosityBlock()==55783 || iEvent.luminosityBlock()==61360 || iEvent.luminosityBlock()==61370 ||iEvent.luminosityBlock()==68258 || iEvent.luminosityBlock()==62147 || iEvent.luminosityBlock()==67194 || iEvent.luminosityBlock()==43070 || iEvent.luminosityBlock()==49429 || iEvent.luminosityBlock()==15102 || iEvent.luminosityBlock()==23306 || iEvent.luminosityBlock()==14242|| iEvent.luminosityBlock()==19080 || iEvent.luminosityBlock()==9312025) return;
  npfjets = 0;
//  if(iEvent.luminosityBlock()<4401) return; 
 //   if(nevt<3442) return;
//  if(nevt!=3080) return;
// cout << "Write test 1 = ok " << endl;
 //=======================*****======================================                                               
  vector<double> recovar;
  vector<double> recovar1;
  std::vector<HepLorentzVector> recomom[njecmx][ntype][njetetamn];
  std::vector<HepLorentzVector> tmpjt4v; 
  std::vector<HepLorentzVector> tmpcand4v;                
  std::vector<HepLorentzVector> tmpgen4v;  
                                                                                             
  std::vector<HepLorentzVector> genmom[nGenReso][ntype][njetetamn];
  vector<double> genvar;

  //====================*****===========================================        

  wtfact=1.0;
//  double px=0;
//  double py=0;
//	double ptxy=0;

 // int ncount=0;
  unsigned ncount=0;
//  double recterm=0;
//  int ithird=-1;
  int irecoht=-1;
	//#ifdef JETENERGY
	int irecohtjec[njecmx];
	for (int ij=0; ij<njecmx; ij++) { irecohtjec[ij]=-1;}
	//#endif	

  int igenht=-1;
	//#ifdef  JETRESO
	int igenhtres[nGenReso];
	for (int ij=0; ij<nGenReso; ij++) { igenhtres[ij]=-1;}
	//#endif

#ifdef TRIGGER
  const char* variab1;
#endif
#ifndef DIJETAVE
  const char* variab2; 
#endif

  if (isMC) {
#ifdef LHAPDF
    edm::Handle<LHEEventProduct> EvtHandle ;
    iEvent.getByToken( lheEventProductToken_ , EvtHandle ) ;
		
		for ( unsigned int weightIndex = 0; weightIndex < EvtHandle->weights().size(); ++weightIndex ) {
			//      cout<< EvtHandle->weights()[weightIndex].wgt <<endl;
      //systematicWeightIDs->push_back( atoi(EvtHandle->weights()[weightIndex].id.c_str()) );
			if (weightIndex>=9 && weightIndex<=109) {
				pdfwt[weightIndex-9] = EvtHandle->weights()[weightIndex].wgt/EvtHandle->originalXWGTUP(); 
				//				std::cout << weightIndex << " " << EvtHandle->weights()[weightIndex].id << " " << EvtHandle->weights()[weightIndex].wgt <<" "<<pdfwt[weightIndex-9]<< std::endl;
			}
    }
#endif
		//		cout<<"AAAAAAAAAAAAAA"<<endl;
    edm::Handle<GenEventInfoProduct> eventinfo;
    iEvent.getByToken(generator1_, eventinfo);
    if (eventinfo.isValid()) { 
      qscale = eventinfo->qScale(); 
      wtfact = eventinfo->weight();
      // weight = weight2*wtfact;
      procid = eventinfo->signalProcessID();
      // cout << " qscale = " <<setw(14)<< qscale << " ; wtfact = " << wtfact << " ; procid = " << procid  << endl;

      if (eventinfo->hasPDF()) {
	const gen::PdfInfo* xpdf = eventinfo->pdf();
	
	int id1 = xpdf->id.first;
	int id2 = xpdf->id.second;
	
	idall = 100*(id1+50)+ (id2+50); 
	
	qscale = xpdf->scalePDF;
	
	xfrac1 = xpdf->x.first;
	xfrac2 = xpdf->x.second;
	
	xpdf1 = xfrac1*xpdf->xPDF.first;
	xpdf2 = xfrac2*xpdf->xPDF.second; 
      }
    }
  }
  
#ifdef TRIGGER
  edm::Handle<edm::TriggerResults> trigRes;
  iEvent.getByToken(triggerBits_, trigRes);
  
  edm::Handle<pat::TriggerObjectStandAloneCollection> triggerObjects;
  iEvent.getByToken(triggerObjects_, triggerObjects);
  
  edm::Handle<pat::PackedTriggerPrescales> triggerPrescales;
  iEvent.getByToken(triggerPrescales_, triggerPrescales);
  //---------------------------------------------------------------------Trigger
  const edm::TriggerNames &names = iEvent.triggerNames(*trigRes);
  //	int ihltfill = -1;
#endif
  
  tmpjt4v.clear();
  tmpcand4v.clear();
  tmpgen4v.clear();
  double aveleadingpt =0;
  bool isInEtaRange[njetetamn]={0}; //GMA{0,0,0,0};
#ifndef GENPART
  edm::Handle<pat::JetCollection> ak4PFJets;
  if (isReconstruct) { 
    iEvent.getByToken(jetSrcToken_, ak4PFJets);
  }
  //  cout<<"1 aveleadingpt"<<endl;
  if (isReconstruct && ((!ak4PFJets.isValid()) ||  ak4PFJets->size() <2)) return; //GMA, do we use this
  
  if (ak4PFJets.isValid() &&  ak4PFJets->size()>=2) {
#ifdef DIJETAVE
    //    aveleadingpt = 0.5*((*ak4PFJets)[0].pt() + (*ak4PFJets)[1].pt());
    //cout<<"1 aveleadingpt"<<aveleadingpt<<endl;
    for (int iet=0; iet<njetetamn; iet++) {
      isInEtaRange[iet] = true;
    }
    
    for (int ij=0; ij<2; ij++) { 
      for (int iet=0; iet<njetetamn; iet++) {
	if (abs((*ak4PFJets)[ij].eta())>etarange[iet]) { isInEtaRange[iet] = false;}
      }
      
      //Jet ID ================= 2018 jetID recomendation 
      double NHF = (*ak4PFJets)[ij].neutralHadronEnergyFraction();
      double NEMF = (*ak4PFJets)[ij].neutralEmEnergyFraction();
      double CHF = (*ak4PFJets)[ij].chargedHadronEnergyFraction();
//      double MUF = (*ak4PFJets)[ij].muonEnergyFraction();
  //    double CEMF = (*ak4PFJets)[ij].chargedEmEnergyFraction();
      int NumConst = (*ak4PFJets)[ij].chargedMultiplicity()+(*ak4PFJets)[ij].neutralMultiplicity();
      //int NumNeutralParticles =(*ak4PFJets)[ij].neutralMultiplicity();
      int CHM = (*ak4PFJets)[ij].chargedMultiplicity();

      bool TightJetID =false;
      if(abs((*ak4PFJets)[ij].eta())<=2.6){
        if (CHM>0 && CHF>0 && NumConst>1 && NEMF<0.9 && NHF < 0.9 ) TightJetID =true;
                               }
               else {      TightJetID =false;
        }
      if (abs((*ak4PFJets)[ij].eta())>2.6) {TightJetID = false;}
       if ((*ak4PFJets)[ij].pt()<30.0) {TightJetID = false;}

      if (TightJetID) {
				aveleadingpt +=(*ak4PFJets)[ij].pt();
      } else {
				aveleadingpt -=100000;
      }
    }
    aveleadingpt /=2.0;
#else

#endif
  }
#endif
  //  cout<<"2 aveleadingpt"<<endl;
  if (isReconstruct && isMC && aveleadingpt>3*qscale) return;

  irecoht = getbinid(aveleadingpt, nHLTmx, leadingPtThreshold);

#ifdef TRIGGER
  bool trgpas[nHLTmx]={0,0,0,0,0,0,0,0};
  //  if (isMC && ak4PFJets.isValid() &&  ak4PFJets->size()>=2) {
  //    aveleadingpt = (*ak4PFJets)[0].pt();
  //    irecoht = getbinid(aveleadingpt, nHLTmx, leadingPtThreshold);
  //  }

  // cout<<"ave"<<aveleadingpt<<" ; Jet1 Pt= " <<   (*ak4PFJets)[0].pt() <<" ; Jet2 Pt= " <<  (*ak4PFJets)[1].pt()<<endl; 
  //std::pair<std::vector<std::pair<std::string,int> >,int> prescaleValuesInDetail(const edm::Event& iEvent, const edm::EventSetup& iSetup, const std::string& trigger) const;
/* 
  //Calcualte Trigger Efficiency for dijet events Manas Sir
 bool trg_fired1=false;
  for (int jk=0; jk<nHLTmx-1; jk++) {
      bool trg_fired=false;
    for(unsigned ij = 0; ij<trigRes->size(); ++ij) {
      std::string name = names.triggerName(ij);
      variab1 = name.c_str();
      //bool trg_fired=false;
      for (int iet=0; iet<njetetamn; iet++) {
	if(aveleadingpt*2>jethlt_thr[jk] && (strstr(variab1,jethlt_name[jk]) && (strlen(variab1)-strlen(jethlt_name[jk])<5)) ){ 
	//if(aveleadingpt*2>jethlt_thr[jk] && aveleadingpt*2<jethlt_thr[jk] && (strstr(variab1,jethlt_name[jk]) && (strlen(variab1)-strlen(jethlt_name[jk])<5)) ){ 
	  //for (int iet=0; iet<njetetamn; iet++) {
	  if (isInEtaRange[iet]) {
	    if (trigRes->accept(ij)) {
                hlt_dijettag[jk][iet]->Fill(aveleadingpt);
	        trg_fired=true;
               } 
	    if(trg_fired) trg_fired1=true;
            else trg_fired1=false;
          if(iet==0)  cout << jk << " ; ij" <<ij <<" ; Prb name "  << variab1 << endl;
	 // }
	//}
	
	if(trg_fired1 && (strstr(variab1,jethlt_name[jk+1]) && (strlen(variab1)-strlen(jethlt_name[jk+1])<5))){
	  if (trigRes->accept(ij) && isInEtaRange[iet]) {hlt_dijetprob[jk][iet]->Fill(aveleadingpt);}
         if(iet==0) cout << jk <<" Tag name "  << variab1 << endl;
	}
       }
      } //for (int iet=0; iet<njetetamn; iet++) {
    }
 }
}
*/
//Calcualte Trigger Efficiency for dijet events Test
/*      
 bool trg_fired1=false; 
  for(unsigned ij = 0; ij<trigRes->size(); ++ij) {
    std::string name = names.triggerName(ij);
    variab1 = name.c_str();
//   std::cout << "Trigger " << names.triggerName(ij) << 
  //              ", prescale " << triggerPrescales->getPrescaleForIndex(ij) <<
    //            ": " << (trigRes->accept(ij) ? "PASS" : "fail (or not run)") 
      //          << std::endl;
    bool trg_fired=false;
    for (int iet=0; iet<njetetamn-2; iet++) {
      if (isInEtaRange[iet]) {
	if((strstr(variab1,jethlt_name[2]) && (strlen(variab1)-strlen(jethlt_name[2])<5))){
	  if (trigRes->accept(ij)) {
	  //if (isL3) {
	    hlt_dijettag[2][iet]->Fill(aveleadingpt);
	    trg_fired=true;
	  if(iet==0) cout <<" Tag name "  << variab1 << endl;
	  }
	  if(trg_fired) trg_fired1=true;
	  else trg_fired1=false;
	}
	if(trg_fired1 && (strstr(variab1,jethlt_name[3]) && (strlen(variab1)-strlen(jethlt_name[3])<5))){
	  //if (trigRes->accept(ij) && isInEtaRange[iet]) {hlt_dijetprob[2][iet]->Fill(aveleadingpt);}
	   if (trigRes->accept(ij)) {
          hlt_dijetprob[2][iet]->Fill(aveleadingpt);
	  if(iet==0) cout <<"Prob name "  << variab1 << endl;
         }
	}   
      }    
    }
  }
*/
  //Calcualte Trigger Efficiency for dijet events
  bool trg_prev=false;

  //   if (!isMC) {
  for (int jk=-1; jk<nHLTmx; jk++) {
    for(unsigned ij = 0; ij<trigRes->size(); ++ij) {
      std::string name = names.triggerName(ij);
      variab1 = name.c_str(); 
      if ((jk<0 && strstr(variab1,jethlt_lowest) && strlen(variab1)-strlen(jethlt_lowest)<5) || 
	  (jk>=0 && strstr(variab1,jethlt_name[jk]) && strlen(variab1)-strlen(jethlt_name[jk])<5)) {
	
	//const std::pair<std::vector<std::pair<std::string,int> >,int> prescalesInDetail(hltConfig_.prescaleValuesInDetail(iEvent,iSetup, variab1));
	const std::pair<std::vector<std::pair<std::string,int> >,int> prescalesInDetail(hltPrescaleProvider_.prescaleValuesInDetail(iEvent,iSetup,variab1));
	if (jk>=0) { 
          //cout<<variab1<<endl;
	  //==============================================================================
	  // double tmpp1= prescalesInDetail.first[0].second;
	  // double tmpp2 = prescalesInDetail.first[1].second;
	  
	  // l1pres[jk] =min(tmpp1, tmpp2);
	  //=====================================================================================
	  l1pres[jk] = prescalesInDetail.first[0].second;
	  
	  if (jk>=3 && l1pres[jk]>1) { l1pres[jk]=1.0;}
	  
	  
          hltpres[jk] = prescalesInDetail.second;	  
	  
	  //compres[jk] = (l1pres[jk])*(triggerPrescales->getPrescaleForIndex(ij));
	  
	  compres[jk] = triggerPrescales->getPrescaleForIndex(ij);
	  //
	  //cout<<"Run NO= "<< iEvent.id().run()<<" ; Event No = "<< iEvent.id().event()<< " ; ilumi = " << iEvent.luminosityBlock() << 
	  //	" ; ibunch = " << iEvent.bunchCrossing()<<" ; L1 Pres0 = " << l1pres[jk] <<" "<<
	  //            " ; HLT Path= "<<name <<" ; HLT Pres = " <<hltpres[jk]<<" ; compres ="<<compres[jk] <<"; irecoht = "<< irecoht <<"; Pt=" <<aveleadingpt<<endl;
	  if (trigRes->accept(ij)) {trgpas[jk] = true;} // ihltfill = jk;}
	  
	  //if (trg_prev && compres[jk]>0.99) {
	  if (trg_prev){
	    for (int iet=0; iet<njetetamn; iet++) {
	      if (isInEtaRange[iet]) { 
		hlt_dijettag[jk][iet]->Fill(aveleadingpt,compres[jk]);
		if (trigRes->accept(ij)) {hlt_dijetprob[jk][iet]->Fill(aveleadingpt, compres[jk]);} //{, (isMC) ? 1.0 : compres[jk]);}
	      }
	    }
	  }
	  /*for (int iet=0; iet<njetetamn; iet++) {
	    if (isInEtaRange[iet]) { 
	    if(trg_prev) hlt_dijettag[jk][iet]->Fill(aveleadingpt);
	    if (trg_prev && trigRes->accept(ij)) {hlt_dijetprob[jk][iet]->Fill(aveleadingpt);} 
	    }    
	    }*/
	  // if (trg_prev) cout << "Accept =" << " name = " <<name <<endl;
	  trg_prev = trigRes->accept(ij);
	  //	  trg_prev = trg_prev|trigRes->accept(ij);
	  //	  if (!trg_prev) { trg_prev = trigRes->accept(ij);}
	  break;
	} else {
	  trg_prev = trigRes->accept(ij);
	  break;
	}
      }
    }
  }
#endif
  // cout<<"ihltfill "<<ihltfill<<endl;
  
  //	cout<<"3 aveleadingpt "<<aveleadingpt<< " ; "<<ihltfill<<" "<<irecoht<<endl;
  
  //	if ((irecoht <0 || irecoht >=nHLTmx) || ((!isMC) && (!trgpas[irecoht]))) return; //GMA remopve this condition
  //  cout <<"irecoht = "<<irecoht<<endl;
  //  if (irecoht==-3) return;
#ifdef TRIGGER
  if (irecoht>=0 && ((!isMC) && (!trgpas[irecoht]))) return;
  if (irecoht==-2 && ((!isMC) && (!trgpas[0]))) return;
#endif
  
  if (!isMC) {
    if (irecoht>=0) {
      wtfact = compres[irecoht];
    } else if (irecoht==-2) {
      wtfact = compres[0];
    } else {
      return ;
    }
  }
  //  for (int ij=0; ij<nHLTmx; ij++) {lumiwt[ij]=intlumi[nHLTmx-1]/intlumi[ij];}// cout<<"nt "<<datpileup[ij][0]<<endl;}
  if (isMC) {
#ifndef GENPART
    //Handle<std::vector< PileupSummaryInfo > >  PupInfo;
    //iEvent.getByLabel("addPileupInfo", PupInfo);
    edm::Handle<std::vector<PileupSummaryInfo> > PupInfo;
    iEvent.getByToken(pileup_, PupInfo);
    int npu = -1;
    PShiftDown_ = reweight::PoissonMeanShifter(-0.5);
    PShiftUp_ = reweight::PoissonMeanShifter(0.5);
    if (PupInfo.isValid()) {
      std::vector<PileupSummaryInfo>::const_iterator PVI;
      for(PVI = PupInfo->begin(); PVI != PupInfo->end(); ++PVI) {
	if (PVI->getBunchCrossing()==0) {
	  //npu = PVI->getPU_NumInteractions();
	  npu = PVI->getTrueNumInteractions();
	  break;
	}
      }
    }
    // double MyWeight = LumiWeights_->weight(npu);
    
    
    // cout << "Main weight = " <<MyWeight << endl;
    //double TotalWeight_plus = MyWeight*PShiftUp_.ShiftWeight( npu );
//double TotalWeight_plus = PShiftUp_.ShiftWeight( npu );
//double TotalWeight_minus = PShiftDown_.ShiftWeight( npu ); 

//cout << "Plus " << wtfact*TotalWeight_plus << " Mi = " << endl;
//cout << "wt= " <<  wtfact << " : weightmi" <<wtfact*TotalWeight_minus << " Mi = " << endl;
 //wtfact=wtfact*TotalWeight_plus; 
// wtfact=wtfact-TotalWeight_minus; 
//    if (npu<0) return; //GMA
    if (isFlat) {
      weight =weight2*wtfact; // for flat MC sample
    } else {
      weight =weight2;
    }
#endif
    defweight = weight;

#ifndef GENPART
        int tmprecht = (irecoht>=0) ? irecoht : 0; //GMA
    
    if (npu<npileupmx) {
          weight *=rat_pileup[tmprecht][npu]; //GMA
    } else {
            weight *=rat_pileup[tmprecht][npileupmx-1]; //GMA
    }
#endif
    
    weighttrg = weight;
    //    cout <<"weight  "<<weight<<" "<< weight2<<endl;
    //sar 3D PU reweighting 111028
  } else {
    weight = weight2;
    defweight = weight2;
    weighttrg = weight*wtfact; // *lumiwt[irecoht];
    //    weighttrg = weight*lumiwt[3];
    // cout <<"TEST2  weighttrg "<< weighttrg<<" ; weight "<<weight<<" ; "<< wtfact<<endl;
  }
  //=====================================
#ifndef GENPART
  if(!isMC){
    reco::TrackBase::Point beamPoint(0,0, 0);
    // math::XYZPoint beamPoint(0,0, 0); 
    
    edm::Handle<reco::BeamSpot> beamSpotH;
    iEvent.getByToken(beamSpot_,beamSpotH);
    if (beamSpotH.isValid()){
      beamPoint = beamSpotH->position();
    }
    
    edm::Handle<reco::VertexCollection> primaryVertices;
    iEvent.getByToken(vtxToken_, primaryVertices);
    
    int tmpvert=0;
    nprim=0;
    if (primaryVertices.isValid()) {
      tmpvert = primaryVertices->size();
      //cout<<"temp"<<tmpvert<<endl;
      for (reco::VertexCollection::const_iterator vert=primaryVertices->begin(); vert<primaryVertices->end(); vert++) {
	int isel = (vert->isValid() && !vert->isFake()) ? 1 : 0;
	int ngoodtrk = 0;
	int nseltrk = 0;
	double prob = ChiSquaredProbability(vert->chi2(),vert->ndof());
	for (reco::Vertex::trackRef_iterator reftrk =vert->tracks_begin(); reftrk<vert->tracks_end(); reftrk++) {
	  if ((*reftrk)->quality(TrackBase::highPurity) && vert->trackWeight(*reftrk)>0) {
	    ngoodtrk++; 
	    if ((*reftrk)->normalizedChi2()<100000 && 
		abs((*reftrk)->dxy()) < 10000 && 
		(*reftrk)->pt() >0.50) {nseltrk++; } 
	  }
	}
	prim_alltrk[isel]->Fill(vert->tracksSize());
	prim_goodtrk[isel]->Fill(ngoodtrk);
	prim_seltrk[isel]->Fill(nseltrk);
	prim_dx[isel]->Fill(vert->position().x() - beamPoint.x());
	prim_dy[isel]->Fill(vert->position().y() - beamPoint.y());
	prim_dxy[isel]->Fill(vert->position().x() - beamPoint.x(), vert->position().y() - beamPoint.y());
	prim_dz[isel]->Fill(vert->position().z() - beamPoint.z());
	prim_prob[isel]->Fill(max(-20.0, log10(prob)));
	
	if (isel==1 && nprim < nprimx-1) {
	  primpr[nprim] = prob;
	  ntkpm[nprim] = 1000*(1000*min(int(vert->tracksSize()),999) + min(ngoodtrk,999)) + min(999, nseltrk);
	  nprim++;
	}
      }
    }
    
    prim_hist[0]->Fill(tmpvert);
    prim_sel[0]->Fill(nprim);
    
    prim_hist_rewt[0]->Fill(tmpvert, weighttrg);
    prim_sel_rewt[0]->Fill(nprim, weighttrg);

    if (irecoht>=0 && irecoht<nHLTmx) { 
      prim_hist[irecoht]->Fill(tmpvert);
      prim_sel[irecoht]->Fill(nprim);
      
      prim_hist_rewt[irecoht]->Fill(tmpvert, weighttrg);
      prim_sel_rewt[irecoht]->Fill(nprim, weighttrg);   
    }
    prim_correl->Fill(tmpvert, nprim);
  } 
#endif 
  //	cout<<"2 aveleadingpt "<<aveleadingpt<< " ; "<<ihltfill<<" "<<irecoht<<endl; 
  
  
  
  vector<double> jetptx[njecmx];
  vector<double> jetscl[njecmx];
  vector<int> jetindx[njecmx];

#ifndef GENPART
  if (ak4PFJets.isValid()) { 
    for(unsigned ijet = 0; ijet != ak4PFJets->size(); ijet++) {
      double pt = (*ak4PFJets)[ijet].pt();
      
      //#ifndef JETENERGY
      //#ifdef JETRESO
      
#if defined(JETRESO)&&(!defined(JETENERGY))
      // resolution file 
      JME::JetResolution resolution = JME::JetResolution("Autumn18_V7b_MC_PtResolution_AK4PFchs.txt");
      // Scalefactor file
      JME::JetResolutionScaleFactor resolution_sf = JME::JetResolutionScaleFactor("Autumn18_V7b_MC_SF_AK4PFchs.txt");
      edm::Handle<double> rho;
      iEvent.getByToken(m_rho_token, rho);
      //		cout<< "  rho=" << *rho << endl;
      
      //      cout << "Write test 3 = ok " << endl;
      double eta = (*ak4PFJets)[ijet].eta();
      double reso = 1;
   
  //2018 JetPt fixed By T. sarkar 
      double sf = resolution_sf.getScaleFactor({{JME::Binning::JetPt, pt}, {JME::Binning::JetEta, eta}}); 
      double sf_up =resolution_sf.getScaleFactor({{JME::Binning::JetPt, pt}, {JME::Binning::JetEta, eta}}, Variation::UP);
      double sf_dn =resolution_sf.getScaleFactor({{JME::Binning::JetPt, pt}, {JME::Binning::JetEta, eta}}, Variation::DOWN);
 	
      double rp = resolution.getResolution(
          {{JME::Binning::JetPt, pt}, {JME::Binning::JetEta, eta}, {JME::Binning::Rho, *rho}});
 

      //#endif
      //#endif
#endif
      
      for (int isrc = 0; isrc < njecmx; isrc++) {
	double sup = 1;
#ifdef JETENERGY
	double eta = (*ak4PFJets)[ijet].eta();
	if (isrc>0 && isrc<=nsrc) {
	  JetCorrectionUncertainty *jecUnc = vsrc[isrc-1];
	  jecUnc->setJetEta(eta);
	  jecUnc->setJetPt(pt);
	  
	  sup += jecUnc->getUncertainty(true);
	} else if (isrc>nsrc) {
	  JetCorrectionUncertainty *jecUnc = vsrc[isrc-nsrc-1];
	  jecUnc->setJetEta(eta);
	  jecUnc->setJetPt(pt);
	  sup -= jecUnc->getUncertainty(false);
	}
#elif defined(JETRESO)
	if (isrc==0) {  
	  reso = sqrt(sf*sf - 1)*rp;
	} else if (isrc==1) {
	  reso = sqrt(sf_up*sf_up - 1)*rp;
	} else if (isrc==2) {
	  reso = sqrt(sf_dn*sf_dn - 1)*rp;
	}
	sup = gRandom->Gaus(1.0, reso);			
#endif
	jetptx[isrc].push_back(sup*pt);
	jetscl[isrc].push_back(sup);
	jetindx[isrc].push_back(ijet);
      }
    }
    //#if defined(JETENERGY)||defined(JETRESO)
    
    for (int isrc = 0; isrc < njecmx; isrc++) {
      for (unsigned int ij=0; ij<jetptx[isrc].size()-1; ij++) {
	for (unsigned int jk=ij+1; jk<jetptx[isrc].size(); jk++) {
	  if (jetptx[isrc][jk]>jetptx[isrc][ij]) {
	    double tmppt = jetptx[isrc][ij];
	    double tmpscl = jetscl[isrc][ij];
	    int tmpindx = jetindx[isrc][ij];
	    
	    jetptx[isrc][ij] = jetptx[isrc][jk];
	    jetscl[isrc][ij] = jetscl[isrc][jk];
	    jetindx[isrc][ij] = jetindx[isrc][jk];					
	    
	    jetptx[isrc][jk] = tmppt;
	    jetscl[isrc][jk] = tmpscl;
	    jetindx[isrc][jk] = tmpindx;
	  }
	}
      }
    }
    //#endif
    
    //    cout<<"1 aveleadingpt "<<endl; //aveleadingpt<< " ; "<<ihltfill<<" "<<irecoht<<endl;
    double aveleadingptjec[njecmx] ={0};
    for (int isrc = 0; isrc < njecmx; isrc++) {
      if (jetptx[isrc].size()>=2) {
	aveleadingptjec[isrc] = 0.5*(jetptx[isrc][0] + jetptx[isrc][1]);
	irecohtjec[isrc] = getbinid(aveleadingptjec[isrc], nHLTmx, leadingPtThreshold);
      } else {
	irecohtjec[isrc] = -1;
      }
    }
    
    //GMA Need the corection on aveleadingpt
    if (ak4PFJets.isValid() && ak4PFJets->size() >=2) { //  && aveleadingpt >leadingPtThreshold[0]) { //GMA look on this
      
      for (int iet=0; iet<njetetamn; iet++) {
	for (int isrc = 0; isrc < njecmx; isrc++) {
	  if (aveleadingptjec[isrc] >leadingPtThreshold[0]) { 
	    int njets=0;
	    ncount=0;
	    //recterm=0;
	   // ithird=-1;
	  //  double sup = 1;	
	   // px=0;
	   // py=0;
	  //  ptxy=0;
	    tmpjt4v.clear();
	    tmpcand4v.clear();
	    tmpgen4v.clear();
	    
	    //				if (abs((*ak4PFJets)[0].eta())<etarange[iet] && abs((*ak4PFJets)[1].eta())<etarange[iet]) {
	    //					for(unsigned ijet = 0; ijet != ak4PFJets->size(); ijet++) {
	    
	    for(unsigned ijet = 0; ijet != ak4PFJets->size(); ijet++) {
	      if (abs((*ak4PFJets)[jetindx[isrc][0]].eta())<etarange[iet] && abs((*ak4PFJets)[jetindx[isrc][1]].eta())<etarange[iet]) {
		int ireorjt = jetindx[isrc][ijet];
		
		double pt = jetptx[isrc][ijet];
		double sup = jetscl[isrc][ijet];
		double abseta = abs((*ak4PFJets)[ireorjt].eta());
	        if (pt<30.0 || abseta >etarange[iet]) continue;	
		//							if (iet==0 && isrc==0) cout <<"pteta "<<pt<<" "<<abseta<<endl;
		bool isEta = (abseta<3.0) ? true : false;
		
		if (isEta && pt>30.0) { njets++;}
		if (abseta>5.0) continue;
		bool isPt = (pt>30.0) ? true : false;
		if (isEta && isPt) {ncount++;}
		
		//cout<< "ncount = " << ncount << endl;
		
		//Jet ID ================= Tight ID 2018 Recomendation 
		double NHF = (*ak4PFJets)[ireorjt].neutralHadronEnergyFraction();
		double NEMF = (*ak4PFJets)[ireorjt].neutralEmEnergyFraction();
		double CHF = (*ak4PFJets)[ireorjt].chargedHadronEnergyFraction();
//		double MUF = (*ak4PFJets)[ireorjt].muonEnergyFraction();
//		double CEMF = (*ak4PFJets)[ireorjt].chargedEmEnergyFraction();
		int NumConst = (*ak4PFJets)[ireorjt].chargedMultiplicity()+(*ak4PFJets)[ireorjt].neutralMultiplicity();
		//int NumNeutralParticles =(*ak4PFJets)[ireorjt].neutralMultiplicity();
		int CHM = (*ak4PFJets)[ireorjt].chargedMultiplicity();
		
		//	  cout<<"NHF== "<< NHF << "; NEF== " << NEMF <<" ; CHF==" <<CHF <<" ;cef==" << CEMF <<"; no= " << NumConst <<" ; nch==" << CHM <<" ; NO of part==" << NumNeutralParticles <<endl;
		
		bool TightJetID =false;
                if(abs((*ak4PFJets)[ireorjt].eta())<=2.6){
                         if (CHM>0 && CHF>0 && NumConst>1 && NEMF<0.9 && NHF < 0.9 ) TightJetID =true;
                                      }
                             else {
                                            TightJetID =false;
                                      }
                if (abs((*ak4PFJets)[ireorjt].eta())>2.6) {TightJetID = false;}
      
                if ((*ak4PFJets)[ireorjt].pt()<30.0) {TightJetID = false;}

		
		if( ireorjt<=1 && !TightJetID) break;
		if (!TightJetID) continue;
		
		//JetID ================
	/*	
		if (ncount <=2 && ncount !=ijet+1) {
		  for (int ix=0; ix<ntype; ix++) { 
		    recomom[isrc][ix][iet].clear(); 
		  }
		  break;
		}*/
		
		//						if (isrc==0 && iet==0) {
		//							cout <<"recomom[isrc][0][iet].size() "<<iet<<" "<<isrc<<" "<<ijet<<" "<<ncount<<" "<<recomom[isrc][0][iet].size()<<" "<<recomom[isrc][1][iet].size()<<" "<<ncount<<" "<<ijet<<endl;
		//						}
		
		HepLorentzVector tmp4v((*ak4PFJets)[ireorjt].px(), (*ak4PFJets)[ireorjt].py(), (*ak4PFJets)[ireorjt].pz(), (*ak4PFJets)[ireorjt].energy());
		
		tmp4v *=sup;
		/*double respfact=respfun(1.02, 0.000004799, 0.000000007044,tmp4v.perp()); 
		  cout <<"Response factor = " <<respfact << endl;
		  tmp4v /=respfact;
		*/
		//cout << "Pt before correction = "<< tmp4v.perp()<< endl;
		/*double  respfact=0.;
		  bool isCorrect=false;   					
		  for (int iresp=0; iresp<7; iresp++){
		  if(abs(tmp4v.eta())> resetarange[iresp] && abs(tmp4v.eta())<resetarange[iresp+1]){
		  respfact=respfun(par0[iresp], par1[iresp], par2[iresp], tmp4v.perp());
		  isCorrect =true;
		  }
		  //		cout << "iresp = "<< iresp << " Eta = " <<tmp4v.eta() <<endl;
		  if(isCorrect) break;
		  }
		  //       cout <<"Response factor = " <<respfact << endl;
		  double invrespfact=0;
		  if (respfact!=0) invrespfact =1/respfact;
		  tmp4v*=invrespfact;*/
		//	cout <<"Response factor = " <<respfact << "Inv Response factor =" << invrespfact << " Corrected Pt = "<< tmp4v.perp() <<endl;
		
		//						cout <<"perp "<<iet<<" "<<isrc<<" "<<ijet<<" "<<sup<<" "<<tmp4v<<" "<<tmp4v.eta()<<" "<<tmp4v.perp()<<" "<<pt<<endl;
		
		if (isEta && isPt) { tmpjt4v.push_back(tmp4v);}
		//tmpjt4v.push_back(tmp4v);	  
		//	 if (isEta && isPt) {allrecojetmom.push_back(tmp4v);}
	//	if (ncount<=2) {  //change for all jet 26th June
		  if (isEta && isPt) {
		    recomom[isrc][0][iet].push_back(tmp4v);
		  }
		  //}
		  //								cout <<"ncount filled "<<ncount<<" "<<isrc<<" "<<iet<<" "<<recomom[isrc][0][iet].size()<<endl;
	//	  px +=tmp4v.px();
	//	  py +=tmp4v.py();
	//	  ptxy +=tmp4v.perp();
		  if (isrc==0) { 
		    if ((isInEtaRange[iet])) {recojt_pt[iet]->Fill(tmp4v.perp(), weighttrg);}
		    if (isPt && iet==0) {recojt_eta->Fill(tmp4v.eta(), weighttrg);}
		    if (isEta && isPt) {recojt_phi->Fill(tmp4v.phi(), weighttrg);}
		    if (isEta && ncount==1) {recoht2_pt[iet]->Fill(aveleadingpt,weighttrg);}
		  }
		//} else {
		/*  if (isrc==0) { 
		    if ((isInEtaRange[iet])) {recojt_oth_pt[iet]->Fill(tmp4v.perp(), weighttrg);}
		    if (isPt && iet==0) {recojt_oth_eta->Fill(tmp4v.eta(), weighttrg);}
		    if (isEta && isPt) {recojt_oth_phi->Fill(tmp4v.phi(), weighttrg);}
		  }*/
		/*  if (isEta && isPt) {
		    double tmppx = px + tmp4v.px();
		    double tmppy = py + tmp4v.py();
		    double tmppt = ptxy + tmp4v.perp();
		    double tmprec = sqrt(pow(tmppx, 2)+pow(tmppy, 2))/tmppt;
		    
		    if (tmprec>recterm) {
		      recterm = tmprec;
		      ithird = ireorjt;
		      //cout <<"ithird Data : "<< ijet<<endl;
		    }
		  }*/
		//}
		if (isrc==0) { 
		  if(ijet==0) { 
		    if (isInEtaRange[iet]) {recojt1_pt[iet]->Fill(tmp4v.perp(), weighttrg);}
		    if (isPt && iet==0) {recojt1_eta->Fill(tmp4v.eta(), weighttrg);}
		    if (isEta && isPt) {recojt1_phi->Fill(tmp4v.phi(), weighttrg);}
		  } else if(ijet==1){
		    if (isInEtaRange[iet]) {recojt2_pt[iet]->Fill(tmp4v.perp(), weighttrg);}
		    if (isPt && iet==0) {recojt2_eta->Fill(tmp4v.eta(), weighttrg);}
		    if (isInEtaRange[iet] && isPt) {recojt2_phi->Fill(tmp4v.phi(), weighttrg);}
		    if (isInEtaRange[iet] && ncount==2) { 
		      if (irecoht>=0 && irecoht<nHLTmx) { 
			recojtave_pt[iet][irecoht]->Fill(aveleadingpt, weighttrg);
			recojtavewt1_pt[iet][irecoht]->Fill(aveleadingpt);
		      }
		      
		      recojtallavewt1_pt[iet]->Fill(aveleadingpt);
		      recojtallave_pt[iet]->Fill(aveleadingpt, weighttrg);
		    }
		    
		  } else if(ijet==2) {
		    if (isInEtaRange[iet]) {recojt3_pt[iet]->Fill(tmp4v.perp(), weighttrg);}
		    if (isPt && iet==0 ) {recojt3_eta->Fill(tmp4v.eta(), weighttrg);}
		    if (isInEtaRange[iet] && isPt) {recojt3_phi->Fill(tmp4v.phi(), weighttrg);}
		  }
		  
		  if (tmpjt4v.size()==2 && isInEtaRange[iet]) { 
		    double dphi = dPhi(tmpjt4v[0].phi(), tmpjt4v[1].phi());
		    double dpt = tmpjt4v[0].perp() - tmpjt4v[1].perp();
		    double dperp = fabs(tmpjt4v[1].perp()*sin(dphi))/tmpjt4v[0].perp();
		    hjetdphi[iet]->Fill(dphi, weighttrg);
		    hjetdpt[iet]->Fill(dpt, weighttrg);
		    hjetptbypl[iet]->Fill(dperp, weighttrg);
		    hjetpt2bypt1[iet]->Fill(tmpjt4v[1].perp()/tmpjt4v[0].perp(), weighttrg);
		  }
		  
		  if (tmpjt4v.size()==3) {hjetpt3bypt2[iet]->Fill(tmpjt4v[2].perp()/tmpjt4v[1].perp(), weighttrg);}
		 } //if (isrc==0) {
		
	        int nchg=0;	
		std::vector<reco::CandidatePtr> daus((*ak4PFJets)[ireorjt].daughterPtrVector());           
		std::sort(daus.begin(), daus.end(), [](const reco::CandidatePtr &p1, const reco::CandidatePtr &p2) { return p1->pt() > p2->pt(); });                                                                                                  
		for (unsigned int i2 = 0; i2< daus.size(); ++i2) {   
		  const pat::PackedCandidate &pfcand = dynamic_cast<const pat::PackedCandidate &>(*daus[i2]);
		  int charge = pfcand.charge();
		  HepLorentzVector cand4v(pfcand.px(), pfcand.py(), pfcand.pz(), pfcand.energy());
		  tmpcand4v.push_back(cand4v);	
                  nchg++;
                  h_nchg[iet]->Fill(nchg, weighttrg);
                  
		  //	   if (cand4v.perp()<0.5) continue;
		//  if (ncount<=2 && isEta && isPt) { 
		    //recomom[isrc][1][iet].push_back(cand4v);
		    
		    if (charge !=0) {
		      recomom[isrc][1][iet].push_back(cand4v);
#ifdef TRACKSYS
		      if (gRandom->Uniform() < 0.96) {recomom[isrc][2][iet].push_back(cand4v); }
#endif
		    }
		   /* if (charge==0) { //other option if need open
		      if (cand4v.perp()>1.0) {
			recomom[isrc][3][iet].push_back(cand4v);
		      }  
		    } else {
		      if (cand4v.perp()>0.5) {
			recomom[isrc][3][iet].push_back(cand4v);
		      }
		    }*/
		    
		    
		    
		    
		    //   double dphi = dPhi(recomom[0][0][0].phi(), recomom[0][0][1].phi());
		    // double dpt = recomom[0][0][0].perp() - recomom[0][0][1].perp();
		    //    double dperp = fabs(tmpcand4v[1].perp()*sin(dphi))/tmpjt4v[0].perp();
		    
		    //	if (dpt<0) cout <<" "<< jk<<" "<<ij<<" "<<mn<<" "<<seljtvar4v[0]<<" "<<seljtvar4v[1]<<" "<<seljtvar4v[0].perp()<<" "<<seljtvar4v[1].perp()<<" "<<endl;
		    
		    //    hjet1dphi->Fill(dphi, weighttrg);
		    //    hjet1dpt->Fill(dpt, weighttrg);
		 // }
		  if (isrc==0) { 
		    //if (isEta && isPt) {
		      if (charge !=0) {
			recochg_phi->Fill(cand4v.phi(), weighttrg);
			recochg_pt->Fill(cand4v.perp(), weighttrg);
			recochg_eta->Fill(cand4v.eta(), weighttrg);
		      }
		    
		      if (ijet==0 && charge !=0) {
                        recochg1_phi->Fill(cand4v.phi(), weighttrg);
                        recochg1_pt->Fill(cand4v.perp(), weighttrg);
                        recochg1_eta->Fill(cand4v.eta(), weighttrg);
		      }
                     else if (ijet==1 && charge !=0) {
                        recochg2_phi->Fill(cand4v.phi(), weighttrg);
                        recochg2_pt->Fill(cand4v.perp(), weighttrg);
                        recochg2_eta->Fill(cand4v.eta(), weighttrg);
                      }
                     else if (ijet==2 && charge !=0) {
                        recochg3_phi->Fill(cand4v.phi(), weighttrg);
                        recochg3_pt->Fill(cand4v.perp(), weighttrg);
                        recochg3_eta->Fill(cand4v.eta(), weighttrg);
                      }                     

		    }//if (isrc==0) {
		//  }
		} //for (unsigned int i2 = 0; i2< daus.size(); ++i2)
		//  if (isEta && isPt) {ncount++;}
	   //   } //if (abs((*ak4PFJets)[jetindx[isrc][0]].eta())<etarange[iet] && abs((*ak4PFJets)[jetindx[isrc][1]].eta())<etarange[iet])
	  //  } // for(unsigned ijet = 0; ijet != ak4PFJets->size(); ijet++)
/*	    if (ithird>=0) {
	      
	      recomom[isrc][0][iet].push_back(tmp4v);
	      //					cout <<"recomom[isrc][0][iet] "<< isrc<<" "<<iet<<" "<<recomom[isrc][0][iet].size()<<endl;
	      // tmpjt4v.push_back(tmp4v);   
	      
	      std::vector<reco::CandidatePtr> daus((*ak4PFJets)[ithird].daughterPtrVector());
	      std::sort(daus.begin(), daus.end(), [](const reco::CandidatePtr &p1, const reco::CandidatePtr &p2) { return p1->pt() > p2 ->pt(); });
	      for (unsigned int i2 = 0; i2< daus.size(); ++i2) {
		const pat::PackedCandidate &pfcand = dynamic_cast<const pat::PackedCandidate &>(*daus[i2]);
		int charge = pfcand.charge();
		HepLorentzVector cand4v(pfcand.px(), pfcand.py(), pfcand.pz(), pfcand.energy());
		//      if (cand4v.perp()<0.5) continue;                                                             
		recomom[isrc][1][iet].push_back(cand4v);
		
		if (charge !=0) {
		  recomom[isrc][2][iet].push_back(cand4v);
#ifdef TRACKSYS
		  if (gRandom->Uniform() < 0.96) {recomom[isrc][4][iet].push_back(cand4v); }
#endif
		  
		}
		if (charge==0){
		  if (cand4v.perp()>1.0) {
		    recomom[isrc][3][iet].push_back(cand4v);
		  }
		} else{
		  if (cand4v.perp()>0.5) {
		    recomom[isrc][3][iet].push_back(cand4v);
		  }
		}
	      }
	    }*/ //if (ithird>=0) 
	    //if (isrc==0) {h_njets[iet]->Fill(ncount, weighttrg);}
	    h_njets[iet]->Fill(ncount, weighttrg);
              } //if (abs((*ak4PFJets)[jetindx[isrc][0]].eta())<etarange[iet] && abs((*ak4PFJets)[jetindx[isrc][1]].eta())<etarange[iet])
            } // for(unsigned ijet = 0; ijet != ak4PFJets->size(); ijet++)
	  } //if (aveleadingptjec[isrc] >leadingPtThreshold[0])
	} // 	for (int isrc = 0; isrc < njecmx; isrc++)
      } //for (int iet=0; iet<njetetamn; iet++)	   
    } // if (ak4PFJets.isValid() && ak4PFJets->size()>=2 && (*ak4PFJets)[0].pt()>leadingPtThreshold[0])
  } // if (ak4PFJets.isValid())
#endif
  
  //  cout << "Write test 31 = ok " << endl;
  //===================********Trigger****============================================================
  
  //t2=clock();
  //float diff ((float)t2-(float)t1);
  //if(diff>30000) return;
  //cout << "Time T2 = " << t2 << " ;Time Diff to Run ="<< diff << endl;
/*  
#ifdef TRIGGER
  if(!isMC){
#ifndef DIJETAVE
    //  vector<triggervar> alltrgobj;
    if (trigRes.isValid() && isReconstruct  &&
	(tmpjt4v.size() ==2 || (tmpjt4v.size()>=3 && tmpjt4v[2].perp()<30.0)) &&
	abs(dPhi(tmpjt4v[0].phi(), tmpjt4v[1].phi()))>2.0){
      
      //  if (trigRes.isValid() && isReconstruct  &&
      //   (tmpjt4v.size() ==2) && abs(dPhi(tmpjt4v[0].phi(), tmpjt4v[1].phi()))>2.0){
      
      int ijet = int(2*gRandom->Uniform())%2;
      int ijet2 = (ijet==0) ? 1 : 0;
      //cout <<"gRandom= "<<gRandom->Uniform() << " ijet" <<ijet<<endl; 
      HepLorentzVector tagjet4v = tmpjt4v[ijet];
      HepLorentzVector probjet4v = tmpjt4v[ijet2];

      vector<triggervar> alltrgobj;
      alltrgobj.clear(); 
      const edm::TriggerNames &names = iEvent.triggerNames(*trigRes);
      for (pat::TriggerObjectStandAlone obj : *triggerObjects) {
	obj.unpackPathNames(names);
	std::vector<std::string> pathNamesAll  = obj.pathNames(false);
	for (unsigned ih = 0, n = pathNamesAll.size(); ih < n; ++ih) {
	  variab2 = pathNamesAll[ih].c_str(); 
	  for (int jk=0; jk<nHLTmx; jk++) {
	    if (strstr(variab2,jethlt_name[jk]) && strlen(variab2)-strlen(jethlt_name[jk])<5){
	      triggervar tmpvec;
	      if( obj.pt()<jethlt_thr[jk] ) continue;
	      tmpvec.both = obj.hasPathName( pathNamesAll[ih], true, true );
	      if(obj.pt()>10){
		tmpvec.both = obj.hasPathName( pathNamesAll[ih], true, true );
		tmpvec.highl  = obj.hasPathName( pathNamesAll[ih], false, true );
		tmpvec.level1 = obj.hasPathName( pathNamesAll[ih], true, false );
		tmpvec.trg4v = HepLorentzVector(obj.px(), obj.py(), obj.pz(), obj.energy());
		tmpvec.prescl = 1;
		tmpvec.ihlt = jk;
		alltrgobj.push_back(tmpvec);
	      }
	    }
	  }
	}
      }
      
      for (unsigned ij=0; ij<alltrgobj.size(); ij++) {
	HepLorentzVector trigger4v = alltrgobj[ij].trg4v;
	int ihlt = -1;
	int tmphlt = alltrgobj[ij].ihlt;
	if( trigger4v.perp()<jethlt_thr[tmphlt] ) continue;
	//      bool isBoth=alltrgobj[ij].both;
	bool isLF =alltrgobj[ij].level1;
	bool isL3 =alltrgobj[ij].highl;
	double angle = deltaR(tagjet4v, trigger4v);
	if (isLF) { 
	  trgjet_angle[tmphlt][0]->Fill(angle);
	  trgjet_2dangle[tmphlt][0]->Fill(trigger4v.perp(), angle);	
	}
	if (isL3) { 
	  trgjet_angle[tmphlt][1]->Fill(angle);
	  trgjet_2dangle[tmphlt][1]->Fill(trigger4v.perp(), angle);		
	}	
	// bool tag=false;
	if (deltaR(tagjet4v, trigger4v)<0.2) {
	  // tag=true;
	  ihlt = alltrgobj[ij].ihlt;
	  if (isLF)  {
	    //        if (isLF && !isBoth)  {
	    trgjet_pt[ihlt][0]->Fill(probjet4v.perp());
	    trgjet_eta[ihlt][0]->Fill(probjet4v.eta());
	    trgjet_phi[ihlt][0]->Fill(probjet4v.phi());
	  }
	  if (isL3) {
	    // if (isLF && !isBoth)  {
	    trgjet_pt[ihlt][1]->Fill(probjet4v.perp());
	    trgjet_eta[ihlt][1]->Fill(probjet4v.eta());
	    trgjet_phi[ihlt][1]->Fill(probjet4v.phi());
	  }
	  
	  for (unsigned jk=0; jk<alltrgobj.size(); jk++) {
	    if (ij==jk || alltrgobj[jk].ihlt !=ihlt) continue;
	    //        if( trigprbjet4v.perp()<jethlt_thr[ihlt] ) continue;
	    HepLorentzVector trigprbjet4v = alltrgobj[jk].trg4v;
	    if( trigprbjet4v.perp()<jethlt_thr[ihlt] ) continue;
	    double angle1 = deltaR(probjet4v, trigprbjet4v);
	    if (isLF && angle1<0.5 ) {
	      //          if (isLF && !isBoth && angle1<0.5 ) {
	      prbjet_pt[ihlt][0]->Fill(probjet4v.perp());
	      prbjet_eta[ihlt][0]->Fill(probjet4v.eta());
	      prbjet_phi[ihlt][0]->Fill(probjet4v.phi());
	      isLF = false;
	    }
	    
	    if (isL3 && angle1<0.2) {
	      //          if (isL3 && !isBoth && angle1<0.2)
	      prbjet_pt[ihlt][1]->Fill(probjet4v.perp());
	      prbjet_eta[ihlt][1]->Fill(probjet4v.eta());
	      prbjet_phi[ihlt][1]->Fill(probjet4v.phi());
	      isL3 = false;
	    }
	    
	    if ((!isL3) && (!isLF)) continue;
	    
	  } //for (unsigned jk=0; jk<alltrgobj.size(); jk++) 
	} //if (deltaR(tagjet4v, trigger4v)<0.2)
	if (ihlt>=0) continue;
      } //for (int ij=0; ij<alltrgobj.size(); ij++)
    } // if (trigRes.isValid() && m_trigeff && isReconstruct  && tmpjt4v.size() ==2) &&
    //      abs(dPhi(tmpjt4v[0].phi(), tmpjt4v[1].phi()))>2.0
#endif
  }
#endif*/
  //======******Trigger Efficiency Normal=======================
  
  //cout << "Write test 1 = ok " << endl;
  //==================================***GenJets*****=================================
  //	cout<<"0 aveleadingpt "<<aveleadingpt<< " ; "<<ihltfill<<" "<<irecoht<<endl;
  if(isMC) {
    
    edm::Handle<reco::GenJetCollection> genjets;
    iEvent.getByToken(genjetToken_,genjets);
    
    double avegenpt =0;
    //    cout <<"HGebjet "<<endl;
    if (genjets.isValid() &&  genjets->size()>=2) {
#ifdef DIJETAVE
      for (int iet=0; iet<njetetamn; iet++) {
	isInEtaRange[iet] = true;
      }
      
      for (int ij=0; ij<2; ij++) {
	for (int iet=0; iet<njetetamn; iet++) {
	  if (abs((*genjets)[ij].eta())>etarange[iet]) { isInEtaRange[iet] = false;}
	}
	
	if (abs((*genjets)[ij].eta())<3.0 && (*genjets)[ij].pt()>30.0) {
	  avegenpt +=(*genjets)[ij].pt();
	} else {
	  avegenpt -=100000;
	}
      }
      avegenpt /=2.0;
      
#else 

#endif
    }
    
    igenht = getbinid(avegenpt, njetptmn, leadingPtThreshold);

    
    //    cout << "Write test 2 = ok " << endl;
    //cout << "Write test 321 = ok " << endl;
    vector<double> genjetptx[nGenReso];
    vector<double> genjetscl[nGenReso];
    vector<int> genjetindx[nGenReso];
    
    for(unsigned ijet = 0; ijet != genjets->size(); ijet++) {
      double pt = (*genjets)[ijet].pt();
      //#ifdef JETRESO		
      //			double eta = (*genjets)[ijet].eta();
      //			double reso = 1;
      //			JME::JetParameters parameters_5 = {{JME::Binning::JetPt, pt}, {JME::Binning::JetEta, eta}, {JME::Binning::Rho, *rho}};
      //			float rp = resolution.getResolution(parameters_5);
      //			float sf = res_sf.getScaleFactor({{JME::Binning::JetEta, eta}});
      //			float sf_up= res_sf.getScaleFactor({{JME::Binning::JetEta, eta}}, Variation::UP);
      //			float sf_dn= res_sf.getScaleFactor({{JME::Binning::JetEta, eta}}, Variation::DOWN);
      
      //#endif		
      for (int isrc = 0; isrc < nGenReso; isrc++) {
	double sup = 1.0;
	//#ifdef JETRESO
	//				if (isrc==0) {  
	//					reso = sqrt(sf*sf - 1)*rp;
	//				} else if (isrc==1) {
	//					reso = sqrt(sf_up*sf_up - 1)*rp;
	//				} else if (isrc==2) {
	//					reso = sqrt(sf_dn*sf_dn - 1)*rp;
	//				}
	
	//				sup = gRandom->Gaus(1.0, reso);
	//				//				cout<<"isrc "<< ijet<<" "<< pt<<" "<<eta<<" "<<isrc<<" rp "<<rp<<" "<<sf<<" "<<sf_dn<<" "<<sf_up<<" "<<reso<<" "<<sup<<endl;
	//#endif
	
	genjetptx[isrc].push_back(sup*pt);
	genjetscl[isrc].push_back(sup);
	genjetindx[isrc].push_back(ijet);
      }
    }
    
    //    cout << "Write test 3 = ok " << endl;
    //    cout << "Write test 322 = ok "<<nGenReso << endl;
    //////#ifdef JETRESO
    for (int isrc = 0; isrc < nGenReso; isrc++) {
      //      cout << "Write test 31 = ok "<<isrc << " ; " << genjetptx[isrc].size() <<endl;
      if(genjetptx[isrc].size()==0) break;
      for (unsigned int ij=0; ij<genjetptx[isrc].size()-1; ij++) {
	//cout << "Write test 32 = ok "<<nGenReso << endl;
	for (unsigned int jk=ij+1; jk<genjetptx[isrc].size(); jk++) {
	  
	  //    if(jk<genjetptx[isrc].size()) return;
	  //cout << "Write test 33 = ok "<<nGenReso << endl;
	  if (genjetptx[isrc][jk]>genjetptx[isrc][ij]) {
	    //cout << "Write test 34 = ok "<<nGenReso << endl;
	    double tmppt = genjetptx[isrc][ij];
	    double tmpscl = genjetscl[isrc][ij];
	    int tmpindx = genjetindx[isrc][ij];
	    
	    genjetptx[isrc][ij] = genjetptx[isrc][jk];
	    genjetscl[isrc][ij] = genjetscl[isrc][jk];
	    genjetindx[isrc][ij] = genjetindx[isrc][jk];					
	    
	    genjetptx[isrc][jk] = tmppt;
	    genjetscl[isrc][jk] = tmpscl;
	    genjetindx[isrc][jk] = tmpindx;
	    //	    cout << "Write test 35 = ok "<<nGenReso << endl;
	  }
	}
      }
    }
    //////#endif
    //    cout << "Write test 4 = ok " << endl;
    double avegenptres[nGenReso]={0};
    
    for (int isrc = 0; isrc < nGenReso; isrc++) {
      if (genjetptx[isrc].size()>=2) {
	avegenptres[isrc] = 0.5*(genjetptx[isrc][0] + genjetptx[isrc][1]);
	igenhtres[isrc] = getbinid(avegenptres[isrc], njetptmn, leadingPtThreshold);
      } else {
	igenhtres[isrc] = -1;
      }
    }
    
    if(genjets.isValid() && genjets->size() >=2) { //  && avegenpt>leadingPtThreshold[0]) { 
      for (int iet=0; iet<njetetamn; iet++) {
	for (int isrc=0; isrc<nGenReso; isrc++) { 
	  if (avegenptres[isrc] > leadingPtThreshold[0]) {
	    //double px =0;
	    //double py =0;
	    //double ptxy =0;
	    
	    ncount=0;
	   //int recterm=0;
	   // int ithird=-1;
	    
	    for(unsigned ijet = 0; ijet < genjets->size(); ijet++) {
	      int igenjt = genjetindx[isrc][ijet];
	     /* if ((*genjets)[igenjt].pt()>25.0) {
		cout<<"ievt "<<ievt<<" "<<ijet<<" "<<igenjt<<" "<<genjetptx[isrc][ijet]<<" "<<(*genjets)[igenjt].pt()<<" "<<(*genjets)[igenjt].eta()<<" "<<(*genjets)[igenjt].phi()<<endl;
	      }*/

	      if (abs((*genjets)[genjetindx[isrc][0]].eta())<etarange[iet] && 
		  abs((*genjets)[genjetindx[isrc][1]].eta())<etarange[iet]) {
		
		
		double pt = genjetptx[isrc][ijet];
		double sup = genjetscl[isrc][ijet];
		double abseta = abs((*genjets)[igenjt].eta());
		if (pt<30.0 || abseta >etarange[iet]) continue;
		
		//								if (iet==0 && isrc==0) 
		//		cout <<"MC:pteta "<<ijet<<" "<<pt<<" "<<abseta<<endl;
		if (abseta>5.0) continue;
		bool isEta = (abseta<3.0) ? true : false;
		
		HepLorentzVector tmp4v((*genjets)[igenjt].px(), (*genjets)[igenjt].py(), (*genjets)[igenjt].pz(), (*genjets)[igenjt].energy());
		tmp4v *=sup;
		bool isPt = (pt>30.0) ? true : false;
		//Response 
		/*if(isPt && isReconstruct) {
		  for(unsigned ijet = 0; ijet != ak4PFJets->size(); ijet++) {
		    HepLorentzVector tmp4vreco((*ak4PFJets)[ijet].px(), (*ak4PFJets)[ijet].py(), (*ak4PFJets)[ijet].pz(), (*ak4PFJets)[ijet].energy());
		    bool isResp=false;
		    for (int iresp=0; iresp<7; iresp++){
		      bool isEtaMatch=false; 
		      if(abs(tmp4v.eta())> resetarange[iresp] && abs(tmp4v.eta())<resetarange[iresp+1]){
			isEtaMatch=true;
			// cout << "Eta Match = " << tmp4v.eta() << " iresp = "<< iresp << endl; 
			double respangle=deltaR(tmp4v,tmp4vreco);
			if(respangle <0.2) {
			  resp_jet[iresp]->Fill(tmp4v.perp(), tmp4vreco.perp()/tmp4v.perp(), weighttrg);
			  resp_jet1[iresp]->Fill(abs((tmp4v.perp()-tmp4vreco.perp())/tmp4v.perp()), weighttrg);
			  //		cout << "Resolution = " << abs((tmp4v.perp()-tmp4vreco.perp())/tmp4v.perp()) << endl;
			  isResp=true;
			}
		      }		
		      if(isEtaMatch) break;
		    }
		    if(isResp) break;
		  }
		}*/
		//Response
		
		//								cout <<"isrc "<<iet<<" "<< isrc <<" "<<igenjt<<" "<<pt<<" " <<tmp4v.perp()<<" "<<tmp4v.eta()<<endl;
		//							pt = tmp4v.perp();
		
		//bool isPt = (pt>30.0) ? true : false;
		if (isEta && isPt) {ncount++;}
		
		/*if (ncount <=2 && ncount !=ijet+1) {
		  for (int ix=0; ix<ntype; ix++) { 
		    genmom[isrc][ix][iet].clear(); 
		  }
		  break;
		}*/
		//							if (isrc==0 && iet==0) cout <<"	genmom[isrc][0][iet].size() "<<genmom[isrc][0][iet].size()<<" "<<ncount<<" "<<igenjt<<" "<<endl;
		
		if (isEta && isPt) { tmpgen4v.push_back(tmp4v);} 
		//if (ncount<=2) {
		  if (isEta && isPt) {
		    genmom[isrc][0][iet].push_back(tmp4v);
		  //  cout <<"twoijx "<<isrc<<" "<<iet<<" "<< genmom[isrc][0][iet].size()<<" "<<tmp4v.perp()<<" "<<tmp4v.eta()<<" "<<tmp4v.phi()<<endl;
		  }
		  //px +=tmp4v.px();
		 // py +=tmp4v.py();
		 // ptxy +=tmp4v.perp();
		  if (isrc==0) { 
		    if (isInEtaRange[iet]) {genjt_pt[iet]->Fill(tmp4v.perp(), weighttrg);}
		    if (isPt && iet==0) {genjt_eta->Fill(tmp4v.eta(), weighttrg);}
		    if (isEta && isPt) {genjt_phi->Fill(tmp4v.phi(), weighttrg);}
		    
		  }
		//} else {
		  /*if (isrc==0) { 
		    if (isInEtaRange[iet]) {genjt_oth_pt[iet]->Fill(tmp4v.perp(), weighttrg);}
		    if (isPt && iet==0) {genjt_oth_eta->Fill(tmp4v.eta(), weighttrg);}
		    if (isEta && isPt) {genjt_oth_phi->Fill(tmp4v.phi(), weighttrg);}
		  }*/
		 /* if (isEta && isPt) {
		    double tmppx = px + tmp4v.px();
		    double tmppy = py + tmp4v.py();
		    double tmppt = ptxy + tmp4v.perp();
		    double tmprec = sqrt(pow(tmppx, 2)+pow(tmppy, 2))/tmppt;
		    
		    if (tmprec>recterm) {
		      recterm = tmprec;
		      ithird = igenjt;
		      // 		      cout <<"ithird MC : "<< igenjt<<" "<<tmp4v.perp()<<" "<<tmp4v.eta()<<endl;
		    }
		  }*/
		//}
		if (isrc==0) { 
		  if(ijet==0) {
		    //		    cout<<"Gen Pt= " << avegenpt <<endl;
		    if (isInEtaRange[iet]) {genjt1_pt[iet]->Fill(tmp4v.perp(), weighttrg);}
		    if (isPt && iet==0) {genjt1_eta->Fill(tmp4v.eta(), weighttrg);}
		    if (isEta && isPt) {genjt1_phi->Fill(tmp4v.phi(), weighttrg);}
		  } else if(ijet==1){
		    //		    cout<<"okkkkkkkk" <<endl;
		    if (isInEtaRange[iet]) {genjt2_pt[iet]->Fill(tmp4v.perp(), weighttrg);}
		    if (isPt && iet==0) {genjt2_eta->Fill(tmp4v.eta(), weighttrg);}
		    if (isInEtaRange[iet] && isPt) {genjt2_phi->Fill(tmp4v.phi(), weighttrg);}
		    if (isInEtaRange[iet] && ncount==2) {
		      //cout<<"Gen Pt 1= " << avegenpt <<endl;
		      genjtallave_pt[iet]->Fill(avegenpt, weighttrg);
		    }
		  } else if(ijet==2) {
		    if (isInEtaRange[iet]) {genjt3_pt[iet]->Fill(tmp4v.perp(), weighttrg);}
		    if (isPt && iet==0 ) {genjt3_eta->Fill(tmp4v.eta(), weighttrg);}
		    if (isInEtaRange[iet] && isPt) {genjt3_phi->Fill(tmp4v.phi(), weighttrg);}
		  }
		  if (tmpgen4v.size()==2 && isInEtaRange[iet]) {
		    double dphi = dPhi(tmpgen4v[0].phi(), tmpgen4v[1].phi());
		    double dpt = tmpgen4v[0].perp() - tmpgen4v[1].perp();
		    double dperp = fabs(tmpgen4v[1].perp()*sin(dphi))/tmpgen4v[0].perp();
		    genjetdphi[iet]->Fill(dphi, weighttrg);
		    genjetdpt[iet]->Fill(dpt, weighttrg);
		    genjetptbypl[iet]->Fill(dperp, weight);
		    genjetpt2bypt1[iet]->Fill(tmpgen4v[1].perp()/tmpgen4v[0].perp(), weight);
		  }
		  
		  if (tmpgen4v.size()==3) {genjetpt3bypt2[iet]->Fill(tmpgen4v[2].perp()/tmpgen4v[1].perp(), weight);}
		}
#ifdef GENPART
		std::vector <const GenParticle*> daus ((*genjets)[igenjt].getGenConstituents ());
		//								std::sort(daus.begin(),daus.end(), [](const reco::CandidatePtr &p1, const reco::CandidatePtr &p2) { return p1->pt() > p2->pt(); }); 
		
		for (unsigned int i2 =0; i2< daus.size(); ++i2) {
		  const GenParticle* pfcand = daus[i2];
		  int charge = pfcand->charge();
		  HepLorentzVector cand4v(pfcand->px(), pfcand->py(), pfcand->pz(), pfcand->energy());
		  //									int pdgid = pfcand->pdgId();
		  
#else								
		  std::vector<reco::CandidatePtr> daus((*genjets)[igenjt].daughterPtrVector());
		  std::sort(daus.begin(),daus.end(), [](const reco::CandidatePtr &p1, const reco::CandidatePtr &p2) { return p1->pt() > p2->pt(); });                               
		  
		  for (unsigned int i2 = 0; i2< daus.size(); ++i2) {
		    const pat::PackedCandidate &pfcand = static_cast<const pat::PackedCandidate &>(*daus[i2]);
		    int charge = pfcand.charge();
		    
		    HepLorentzVector cand4v(pfcand.px(), pfcand.py(), pfcand.pz(), pfcand.energy());
#endif
		    //	    if (cand4v.perp()<0.5) continue;
		    
		    //if (ncount<=2 && isEta && isPt) {
		      //genmom[isrc][1][iet].push_back(cand4v);
		      if (charge !=0) {
			genmom[isrc][1][iet].push_back(cand4v);
#ifdef TRACKSYS
			if (gRandom->Uniform() < 0.96) {genmom[isrc][2][iet].push_back(cand4v); }
#endif
		      }
		      
		      //   if (charge ==0) {genmom[isrc][2][iet].push_back(cand4v);}
		      
		     /* if(charge ==0) {
			if (cand4v.perp()>1.0) {
			  genmom[isrc][3][iet].push_back(cand4v);
			}
		      } else {
			if (cand4v.perp()>0.5) {
			  genmom[isrc][3][iet].push_back(cand4v);
			}
		      }*/
		    //}
		    if (isrc==0) { 
			if (charge !=0) {
		      if (isEta && isPt) {
			  genchg_phi->Fill(cand4v.phi(), weighttrg);
			} 
                      if (isEta) {
                         genchg_pt->Fill(cand4v.perp(), weighttrg);
                         }
                      if (isPt) {
                         genchg_eta->Fill(cand4v.eta(), weighttrg);
                        }

                       if(ijet==0) {
                      if (isEta && isPt) {
                          genchg1_phi->Fill(cand4v.phi(), weighttrg);
                        }
                      if (isEta) {
                         genchg1_pt->Fill(cand4v.perp(), weighttrg);
                         }
                      if (isPt) {
                         genchg1_eta->Fill(cand4v.eta(), weighttrg);
                        }                      
                      }

                      if(ijet==1) {
                      if (isEta && isPt) {
                          genchg2_phi->Fill(cand4v.phi(), weighttrg);
                        }
                      if (isEta) {
                         genchg2_pt->Fill(cand4v.perp(), weighttrg);
                         }
                      if (isPt) {
                         genchg2_eta->Fill(cand4v.eta(), weighttrg);
                        }
                      }
                  
                      if(ijet==2) {
                      if (isEta && isPt) {
                          genchg3_phi->Fill(cand4v.phi(), weighttrg);
                        }
                      if (isEta) {
                         genchg3_pt->Fill(cand4v.perp(), weighttrg);
                         }
                      if (isPt) {
                         genchg3_eta->Fill(cand4v.eta(), weighttrg);
                        }
                      }

		      }//if (charge !=0) { 
                      
                    /*if (isEta) {
                        if (charge !=0) {
                          genchg_pt->Fill(tmp4v.perp(), weighttrg);
                        }
                    if (isPt) {
                        if (charge !=0) {
                          genchg_eta->Fill(tmp4v.eta(), weighttrg);
                        }                      

else {
			if (charge !=0) {
			  genchg_oth_phi->Fill(tmp4v.phi(), weighttrg);
			} else {
			  genneu_oth_phi->Fill(tmp4v.phi(), weighttrg);
			}
		      }
		      
		      if (isEta) {
			if (charge !=0) {
			  genchg_pt->Fill(tmp4v.perp(), weighttrg);
			} else {
			  genneu_pt->Fill(tmp4v.perp(), weighttrg);
			}
		      } else {
			if (charge !=0) {
			  genchg_oth_pt->Fill(tmp4v.perp(), weighttrg);
			} else {
			  genneu_oth_pt->Fill(tmp4v.perp(), weighttrg);
			}
		      }
		      if (isPt) {
			if (charge !=0) {
			  genchg_eta->Fill(tmp4v.eta(), weighttrg);
			} else {
			  genneu_eta->Fill(tmp4v.eta(), weighttrg);
			}
		      } else {
			if (charge !=0) {
			  genchg_oth_eta->Fill(tmp4v.eta(), weighttrg);
			} else {
			  genneu_oth_eta->Fill(tmp4v.eta(), weighttrg);
			}
		      }*/
		    } //if (isrc==0)
		  } //for (unsigned int i2 = 0; i2< daus.size(); ++i2)
		  //  if (isEta && isPt) {ncount++;}
		} // if (abs((*genjets)[genjetindx[isrc][0]].eta())<etarange[iet] && 
		//								abs((*genjets)[genjetindx[isrc][1]].eta())<etarange[iet])
	      } //	for(unsigned ijet = 0; ijet != genjets->size(); ijet++) 
	      //cout << "Write test 324 = ok " << endl;
	     /* if (ithird>=0) {
		//							cout <<"ithird "<<isrc<<" "<< iet<<" "<< ithird<<endl;
		
		HepLorentzVector tmp4v((*genjets)[ithird].px(), (*genjets)[ithird].py(), (*genjets)[ithird].pz(), (*genjets)[ithird].energy());
		genmom[isrc][0][iet].push_back(tmp4v);
		//cout <<"thirdijxxx "<<isrc<<" "<<iet<<" "<< genmom[isrc][0][iet].size()<<" "<<genjets->size()<<" "<<ithird<<" "<<tmp4v.perp()<<" "<<tmp4v.eta()<<" "<<tmp4v.phi()<<" "<<setprecision(14)<<weighttrg<<endl;
#ifdef GENPART
		std::vector <const GenParticle*> daus ((*genjets)[ithird].getGenConstituents ());
		//								std::sort(daus.begin(),daus.end(), [](const reco::CandidatePtr &p1, const reco::CandidatePtr &p2) { return p1->pt() > p2->pt(); }); 
		
		for (unsigned int i2 =0; i2< daus.size(); ++i2) {
		  const GenParticle* pfcand = daus[i2];
		  int charge = pfcand->charge();
		  HepLorentzVector cand4v(pfcand->px(), pfcand->py(), pfcand->pz(), pfcand->energy());
		  //								int pdgid = pfcand->pdgId();
		  
#else
		  std::vector<reco::CandidatePtr> daus((*genjets)[ithird].daughterPtrVector());
		  std::sort(daus.begin(),daus.end(), [](const reco::CandidatePtr &p1, const reco::CandidatePtr &p2) { return p1->pt() > p2->pt(); });    
		  
		  for (unsigned int i2 = 0; i2< daus.size(); ++i2) {
		    const pat::PackedCandidate &pfcand = static_cast<const pat::PackedCandidate &>(*daus[i2]);
		    
		    int charge = pfcand.charge();
		    HepLorentzVector cand4v(pfcand.px(), pfcand.py(), pfcand.pz(), pfcand.energy());
#endif
		    
		    
		    //      if (cand4v.perp()<0.5) continue;                                                                                                                     
		    genmom[isrc][1][iet].push_back(cand4v);
		    if (charge !=0) {
		      genmom[isrc][2][iet].push_back(cand4v);
#ifdef TRACKSYS
		      if (gRandom->Uniform() < 0.96) {genmom[isrc][4][iet].push_back(cand4v); }
#endif
		    }
		    
		    if(charge ==0) {
		      if (cand4v.perp()>1.0) {
			genmom[isrc][3][iet].push_back(cand4v);
		      }
		    } else {
		      if (cand4v.perp()>0.5) {
			genmom[isrc][3][iet].push_back(cand4v);
		      }
		    }
		  } //for (unsigned int i2 = 0; i2< daus.size(); ++i2) 
		}*/// if (ithird>=0)
		gen_njets[iet]->Fill(ncount,weighttrg); 
	      } // if (avegenptres[isrc] > leadingPtThreshold[0])
	    } //	for (int isrc=0; isrc<nGenReso; isrc++)
	  } //for (int iet=0; iet<njetetamn; iet++)
	} // if(genjets.isValid() && genjets->size()>=2 && (*genjets)[0].pt()>leadingPtThreshold[0])
	// } //if (genjets.isValid() &&  genjets->size()>=2) 
	h_2ht->Fill(aveleadingpt,avegenpt, weighttrg);
	///////Response
      } //isMC
      //	cout<<"22 aveleadingpt "<<aveleadingpt<< " ; "<<ihltfill<<" "<<irecoht<<endl;
      // if(isMC) h_2ht->Fill(aveleadingpt,avegenpt, weighttrg);
      //cout << "Write test 325 = ok " << endl;
      //for(int rnum=0; rnum<10; rnum++) {
      /*double rand=gRandom->Uniform();
      int k = rand/0.1;
//      cout << "Rand Number " << k << endl;*/
  
      
      for (int itp=0; itp<ntype; itp++) {
//      for (int itp=0; itp<1; itp++) {
	for (int iet=0; iet<njetetamn; iet++) {
	  if (isReconstruct) { 
	    for (int isrc=0; isrc<njecmx; isrc++) { 
	      recovar.clear();
	      recovar1.clear();
	      if (isrc==0) {isRECO[itp][iet]=false;}
	      //				if (iet==0 && isrc==0) 
	    //  cout <<"reco "<< itp<<" "<<iet<<" "<<isrc<<" "<<irecohtjec[isrc]<<" "<<recomom[isrc][itp][iet].size()<<endl;
	      if (irecohtjec[isrc]>=0 && irecohtjec[isrc]<njetptmn && recomom[isrc][itp][iet].size()>1) {
		EventShape_vector  recoevtshape(recomom[isrc][itp][iet], 2.4, 0, 2, 1);
		recovar =  recoevtshape.getEventShapes();
		if (recovar[nvar]>=3) {
		  if (isrc==0) {isRECO[itp][iet] = true;}
		  for (int ij=0; ij<nvar; ij++) {
		    if (isItUsed(ij)) { 
		      if (isrc==0) { 
			if (int(recovar[nvar])>=3) {
	//	cout<<"recovar "<<ievt<<" "<<recovar[nvar]<<" "<<recomom[isrc][itp][iet].size()<<endl;//" "<<genvar[3]<<" "<<genvar[9]<<" "<<genvar[18]<<" "<<genvar[24]<<endl;
				h_recoevtvar[itp][irecohtjec[isrc]][iet][ij]->Fill(recovar[ij], weighttrg); 
			}
			/*for (int irand=0; irand<10; irand++) {
			  if(irand !=k ) h_recoevtvar[irand][itp][irecohtjec[isrc]][iet][ij]->Fill(recovar[ij], weighttrg); 
			  //#ifdef LHAPDF
			  //						   			for (int ix=1; ix<nnnmx; ix++) {
			  //							  			h_recoevtvarpdf[itp][irecohtjec[isrc]][iet][ij][ix]->Fill(recovar[ij], weighttrg*pdfwt[ix]); 
			  //								  	}
			  //#endif
			  }*/	
		      } else {
#ifdef JETENERGY
			if (int(recovar[nvar])>=3) {h_recoevtvarjec[itp][irecohtjec[isrc]][iet][ij][isrc]->Fill(recovar[ij], weighttrg);}
#elif defined(JETRESO)
			if (int(recovar[nvar])>=3) {h_recoevtvarres[itp][irecohtjec[isrc]][iet][ij][isrc]->Fill(recovar[ij], weighttrg);}
#endif
		      }
		    }
		  }
		}
	      }
	    }
	  } // if (isReconstruct)
	  //cout << "Time Diff to Run ="<< diff << endl;
	  
	  if(isMC) {
	    for (int isrc=0; isrc<nGenReso; isrc++) {
	      //	    for (int isrc=0; isrc<1; isrc++) { 
	      genvar.clear();
	      bool isGEN=false;
	      if (igenhtres[isrc]>=0 && igenhtres[isrc]<njetptmn && genmom[isrc][itp][iet].size()>1) { 
		//						cout <<"itp "<< itp<<" "<<iet<<" "<<isrc<<" "<<genmom[isrc][0][iet].size()<<" "<<genmom[isrc][itp][iet].size()<<endl; 
		EventShape_vector  genevtshape(genmom[isrc][itp][iet], 2.4, 0, 2, 1);
		
		genvar =  genevtshape.getEventShapes();
		
		//cout<<"genvar "<<igenhtres[isrc]<<" "<<ievt<<" "<<genvar[nvar]<<" "<<genmom[isrc][itp][iet].size()<<" "<<genvar[3]<<" "<<genvar[9]<<" "<<genvar[18]<<" "<<genvar[24]<<endl;
		if (genvar[nvar]>=3) {
		  isGEN = true;
		  for (int ij=0; ij<nvar; ij++) {
		    if (isItUsed(ij)) { 
		      if (isrc==0) { 
			if (int(genvar[nvar])>=3) {
			  h_genevtvar[itp][igenhtres[isrc]][iet][ij]->Fill(genvar[ij], weighttrg);
			} //else {
			  //h_genevtvar2[itp][igenhtres[isrc]][iet][ij]->Fill(genvar[ij], weighttrg);
			//}
			
#ifdef JETRESO
			//									} else {
			//										h_genevtvarres[itp][igenhtres[isrc]][iet][ij][isrc]->Fill(genvar[ij], weighttrg);	
#endif
#ifdef LHAPDF
			for (int ix=1; ix<nnnmx; ix++) {
			  if (int(genvar[nvar])>=3) {h_genevtvarpdf[itp][igenhtres[isrc]][iet][ij][ix]->Fill(genvar[ij], weighttrg*pdfwt[ix]);}
			}
#endif
		      }
		    }
		  }
		}
		if (isrc==0 && isReconstruct) { 
		  for(int ij=0; ij<nvar; ij++) {
		    if (isItUsed(ij)) { 	
		      if (isRECO[itp][iet] && isGEN && irecoht==igenht) { 
			naa++;
			if (irecoht>=0 && irecoht<nHLTmx) {
	                  if (recovar[nvar]>=3 &&  genvar[nvar]>=3) {
			  	h_2devtvar[itp][irecoht][iet][ij]->Fill(recovar[ij], genvar[ij], weighttrg);
			  }else if (recovar[nvar]>=3) {
                            h_2devtvar[itp][irecoht][iet][ij]->Fill(recovar[ij], 1.1, weighttrg);
                           }else if (genvar[nvar]>=3) {
                              h_2devtvar[itp][irecoht][iet][ij]->Fill(1.1, genvar[ij], weighttrg);
                            }
			}
			//  h_2devtvar[itp][0][iet][ij]->Fill(recovar[ij], genvar[ij], weighttrg);
		      } else {
			if (isRECO[itp][iet]) {
			  nbb++;
			  if (irecoht>=0 && irecoht<nHLTmx && recovar[nvar]>=3) {
			    //for (int irand=0; irand<10; irand++) {
			      h_2devtvar[itp][irecoht][iet][ij]->Fill(recovar[ij], 1.1, weighttrg);
			      //if(irand !=k ) h_2devtvar[irand][itp][irecoht][iet][ij]->Fill(recovar[ij], 1.1, weighttrg);
			    //}
			  }
			}
			if (isGEN) {
			  ncc++;
			  if (igenht>=0 && igenht<nHLTmx && genvar[nvar]>=3) {
			    //for (int irand=0; irand<10; irand++) {
			      h_2devtvar[itp][igenht][iet][ij]->Fill(1.1, genvar[ij], weighttrg);	
			      //if(irand !=k ) h_2devtvar[irand][itp][igenht][iet][ij]->Fill(1.1, genvar[ij], weighttrg);	
			    //}
			  }
			}
		      }
		    } //if (isItUsed(ij)) 
		  } // for(int ij=0; ij<nvar; ij++)	
		} // if (isrc==0 && isReconstruct)
	      } // if (igenht>=0 && igenht<njetptmn && genmom[isrc][itp][iet].size()>1)
	    } // for (int isrc=0; isrc<nGenReso; isrc++)
	  }//isMC
	} // for (int iet=0; iet<njetetamn; iet++)
      } //for (int itp=0; itp<ntype; itp++) 
      
      //	if (nevt%1000==1) { std::cout <<"nevt "<<nevt<<" naa "<<naa<<" nbb "<<nbb<<" ncc "<<ncc<< std::endl;}
      
      //cout << "Write test 33 = ok " << endl;
    }

// ------------ method called once each job just before starting event loop  ------------
void 
QCDEventShape::beginJob() {
//  t1=clock();
  nevt = 0;
  if (isMC) { 
    double dattot[nHLTmx]={0};
    double mctot=0;
    for (int ij=0; ij<npileupmx; ij++) {
      for (int jk=0; jk<nHLTmx; jk++) {
				dattot[jk] +=datpileup[jk][ij];
      }
      mctot +=mcpileup[ij];
    }
    
    for (int ij=0; ij<npileupmx; ij++) {
      mcpileup[ij] /=max(1.e-6,mctot);
      for (int jk=0; jk<nHLTmx; jk++) {
				datpileup[jk][ij] /=max(1.e-6,dattot[jk]);
				
				rat_pileup[jk][ij] =  datpileup[jk][ij]/mcpileup[ij];
      }
    }
  }

#ifdef JETENERGY
  for (int isrc = 0; isrc < nsrc; isrc++) {
    const char *name = srcnames[isrc];
//    JetCorrectorParameters *p = new JetCorrectorParameters("Fall15_25nsV2_DATA_UncertaintySources_AK4PF.txt", name);
   JetCorrectorParameters *p = new JetCorrectorParameters("Autumn18_V19_MC_UncertaintySources_AK4PFchs.txt", name);
 // JetCorrectorParameters *p = new JetCorrectorParameters("Fall17_17Nov2017_V6_MC_UncertaintySources_AK4PFchs.txt", name);    
//  JetCorrectorParameters *p = new JetCorrectorParameters("Fall17_17Nov2017F_V6_DATA_UncertaintySources_AK4PFchs.txt", name);    
JetCorrectionUncertainty *unc = new JetCorrectionUncertainty(*p);
		//    vsrc[isrc] = unc;
		vsrc.push_back(unc);
  }
#endif  


//cout << "Write test 34 = ok " << endl;
}

// ------------ method called once each job just after ending the event loop  ------------
void 
QCDEventShape::endJob() 
{
  //theFile->cd();
  //theFile->Write();
  //theFile->Close();
  //myfile1->Close();
  //fs->Write();
  //fs->Close();
}

// ------------ method called when starting to processes a run  ------------

void 
QCDEventShape::beginRun(edm::Run const& iRun, edm::EventSetup const& iSetup)
{
// Initialize hltConfig

#ifdef TRIGGER

// cout << "Write test 4 = ok " << endl;
	bool changed(true);
  if (hltPrescaleProvider_.init(iRun,iSetup,theHLTTag.c_str(),changed)) {
  HLTConfigProvider const&  hltConfig = hltPrescaleProvider_.hltConfigProvider();
    hltConfig.dump("Triggers");
    hltConfig.dump("PrescaleTable");

    for (unsigned int ij=0; ij<nHLTmx; ij++) {
      l1pres[ij] = hltpres[ij]=-7;
    }

       } else {
         }



/*   bool changedConfig;
   if (!hltConfig_.init(iRun, iSetup, theHLTTag.c_str(), changedConfig)) {
     LogError("HLTMuonVal") << "Initialization of HLTConfigProvider failed!!"; 
     return;
 
    //for (unsigned int ij=0; ij<nHLTmx; ij++) {
      //l1pres[ij] = hltpres[ij]=-7;
    //}

  }*/
 
/* 
bool changed(true);
  if (hltConfig_.init(iRun,iSetup,theHLTTag.c_str(),changed)) {
//    cout <<"Trigger tables "<<endl;
    hltConfig_.dump("Triggers");
//    cout <<"Prescale tables "<<endl;
    hltConfig_.dump("PrescaleTable");

    for (unsigned int ij=0; ij<nHLTmx; ij++) {
      l1pres[ij] = hltpres[ij]=-7;
    }

    //trig_init=0; //GMA
    //    // ..
       } else {
              // ..
         }

*/




/* bool changed(true);
   if (hltConfig_.init(iRun,iSetup,theHLTTag.c_str(),changed)) {
     if (changed) {
      // check if trigger name in (new) config
       if (triggerName_!="@") { // "@" means: analyze all triggers in config
     const unsigned int n(hltConfig_.size());
     const unsigned int triggerIndex(hltConfig_.triggerIndex(triggerName_));
     if (triggerIndex>=n) {
       LogVerbatim("HLTEventAnalyzerAOD") << "HLTEventAnalyzerAOD::analyze:"
            << " TriggerName " << triggerName_ 
            << " not available in (new) config!" << endl;
       LogVerbatim("HLTEventAnalyzerAOD") << "Available TriggerNames are: " << endl;
       hltConfig_.dump("Triggers");
     }
       }
       hltConfig_.dump("ProcessName");
       hltConfig_.dump("GlobalTag");
       hltConfig_.dump("TableName");
       hltConfig_.dump("Streams");
       hltConfig_.dump("Datasets");
       hltConfig_.dump("PrescaleTable");
       hltConfig_.dump("ProcessPSet");
     }
   } else {
     LogVerbatim("HLTEventAnalyzerAOD") << "HLTEventAnalyzerAOD::analyze:"
      << " config extraction failure with process name "
      << processName_ << endl;
   }
 
*/
#endif
 
  std::cout<<" End of QCDEventShape::beginRun"<<std::endl; //"nevt "<<nevt<<" naa "<<naa<<" nbb "<<nbb<<" ncc "<<ncc<< std::endl;
}


// ------------ method called when ending the processing of a run  ------------
/*
void 
QCDEventShape::endRun(edm::Run const& iRun, edm::EventSetup const& iSetup)
{
std::cout<<" End of QCDEventShape::beginRun"<<std::endl;
}
*/

// ------------ method called when starting to processes a luminosity block  ------------
/*
void 
QCDEventShape::beginLuminosityBlock(edm::LuminosityBlock const&, edm::EventSetup const&)
{


}
*/

// ------------ method called when ending the processing of a luminosity block  ------------
/*
void 
QCDEventShape::endLuminosityBlock(edm::LuminosityBlock const&, edm::EventSetup const&)
{
}
*/

// ------------ method fills 'descriptions' with the allowed parameters for the module  ------------
void
QCDEventShape::fillDescriptions(edm::ConfigurationDescriptions& descriptions) {
  //The following says we do not know what parameters are allowed so do no validation
  // Please change this to state exactly what you do use, even if it is no parameters
  edm::ParameterSetDescription desc;
  desc.setUnknown();
  descriptions.addDefault(desc);
}

double PhiInRange(const double& phi) {
      double phiout = phi;
      
      if( phiout > 2*M_PI || phiout < -2*M_PI) {
	phiout = fmod( phiout, 2*M_PI);
      }
      if (phiout <= -M_PI) phiout += 2*M_PI;
      else if (phiout >  M_PI) phiout -= 2*M_PI;
      
      return phiout;
}

template <class T, class U>
double deltaR(const T& t, const U& u) {
  return sqrt(pow(t.eta()-u.eta(),2) +pow(PhiInRange(t.phi()-u.phi()),2));
}



//define this as a plug-in
DEFINE_FWK_MODULE(QCDEventShape);

/*
L1_ZeroBias 	29989	5327	5327	5327	5327	1601	801	801	801	801	801	801	801
17	L1_SingleJet52 	3000	10000	6000	4000	3000	1500	800	500	400	300	150	100	262139
18	L1_SingleJet68 	1500	1500	1000	750	500	300	150	100	75	50	30	15	262139
19	L1_SingleJet92 	3000	3000	2000	2000	1500	800	400	300	200	150	80	40	262139
20	L1_SingleJet128 1000	1000	1	1	1	1	1	1	1	1	1	1	262139
21	L1_SingleJet176 300	300	1	1	1	1	1	1	1	1	1	1	262139


66	HLT_DiPFJetAve40_v2 (2013430) 	25 	25 	16 	12 	8 	5 	3 	2 	1 	1 	1 	1 	0 	L1_ZeroBias
69	HLT_DiPFJetAve60_v2 (2013431) 	1 	1 	1 	1 	1 	1 	1 	1 	1 	1 	1 	1 	0 	L1_ZeroBias
71	HLT_DiPFJetAve80_v2 (2013432) 	7 	7 	7 	7 	7 	7 	7 	7 	7 	7 	7 	7 	7 	L1_SingleJet52
58	HLT_DiPFJetAve140_v2 (2013433) 	2 	2 	2 	2 	1 	1 	1 	1 	1 	1 	1 	1 	1 	L1_SingleJet92
60	HLT_DiPFJetAve200_v2 (2013434) 	250 	250 	125 	85 	60 	35 	16 	12 	9 	6 	4 	2 	1 	L1_SingleJet128
62	HLT_DiPFJetAve260_v2 (2013435) 	85 	85 	85 	60 	42 	24 	12 	8 	6 	4 	2 	1 	1 	L1_SingleJet128 OR L1_SingleJet176
64	HLT_DiPFJetAve320_v2 (2013436) 	15 	15 	15 	10 	6 	4 	2 	1 	1 	1 	1 	1 	1 	L1_SingleJet128 OR L1_SingleJet176
65	HLT_DiPFJetAve400_v2 (2013437) 	5 	5 	5 	3 	2 	1 	1 	1 	1 	1 	1 	1 	1 	L1_SingleJet128 OR L1_SingleJet176
67	HLT_DiPFJetAve500_v2 (2013438) 	1 	1 	1 	1 	1 	1 	1 	1 	1 	1 	1 	1 	1 	L1_SingleJet128 OR L1_SingleJet176
*/
